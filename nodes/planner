#!/usr/bin/env python
import rospy
import signal
import sys
import math
import tf
import PyKDL
import copy
import numpy as np
import actionlib

from geometry_msgs.msg import Twist,Pose,PoseStamped,Quaternion,Vector3,Wrench
from nav_msgs.msg import Path
from std_msgs.msg import String, Bool

from sensor_msgs.msg import JointState
from panda_ros_msgs.msg import JointPose, HybridPose

from authoring_msgs.msg import Action,Command
import authoring_msgs.msg

import threading

REFERENCE_FRAME='panda_link0'
CLIENT_ACTIVE=1
SIM = True
EXEC = False
class Planner(object):
    def __init__(self):
        self._tl = tf.TransformListener()
        self._br = tf.TransformBroadcaster()

        self._plan = []
        self._running = False
        self._sim = False
        self._skip = False
        self._act = False
        self._integrator = Twist()
        self._freq = 1000.
        self._force = Vector3()
        self._inserting_factor = None
        self._plan_z = None
        self._current_joint = None
        self._gripper_acting = False
        self._gripper_done = False
        self._pause = False
        self._current_action_progress = []
        self._angle_move = False
        self._plan_following_thread = threading.Thread()

        rospy.sleep(2.5) # sleep a bit to make sure the TF cache is filled
        self._path_pub = rospy.Publisher("/planner/path", Path, queue_size=0)
        self._camera_pub = rospy.Publisher("/panda/camera_control", Bool, queue_size=0)
        self._goal_pub = rospy.Publisher("/planner/goal_pose", HybridPose, queue_size=5)
        self._cam_goal_pub = rospy.Publisher("/planner/cam_goal_pose", PoseStamped, queue_size=5)
        self._command_sub = rospy.Subscriber("/parser/command", Command, self.on_command)
        self._event_pub = rospy.Publisher("/event",String,queue_size = 5)
        self._command_pub = rospy.Publisher("/planner/command", String, queue_size=1)
        self._force_sub = rospy.Subscriber("/panda/wrench", Wrench, self.on_force)
        self._event_sub = rospy.Subscriber("/event", String, self.on_event)
        self._fd_sub = rospy.Subscriber("/fd/button", Bool, self.on_fd)

        #For angle control
        self._panda_angle_sub = rospy.Subscriber("/viz/joint_states", JointState, self.on_state, queue_size=1)
        self._angle_pub = rospy.Publisher("/planner/joint_pose", JointPose, queue_size = 5)

        #Client stuff
        self._client = actionlib.SimpleActionClient('mover_server', authoring_msgs.msg.AuthoringAction)

    def on_state(self, msg):
        self._current_joint = msg

    def on_force(self, msg):
        self._force = msg.force

    def on_fd(self, msg):
        if msg.data:
            self.next_sub_action()
            
    def on_event(self, msg):
        if msg.data == "pause":
            self._pause = True
        if msg.data == "play" or msg.data == "stop_edit":
            self._pause = False
        if msg.data == "act":
            self._act = True
        if msg.data == "skip":
            self._skip = True
        if msg.data == "grasping_done" or msg.data == "releasing_done":
            self._gripper_done = True
            self._gripper_acting = False

    def add_subaction(self, action, sim, plan = None, sub_action = False):
        if plan is None:
            plan = self._plan
        rot = tf.transformations.quaternion_from_euler(0,0,0)
        ref_pose = PoseStamped()
        ref_pose.header = action.poses.header
        ref_pose.pose = action.poses.poses[0]
        q = Quaternion(rot[0],rot[1],rot[2],rot[3])
        #print(ref_pose)

        if action.type == action.MOVE_OBJECT:
            a1 = Action(sim=Bool(sim))
            a1.type = a1.PICK
            a1.item = String(action.item.data.split('-')[0])
            a1.poses.header = action.poses.header
            a1.poses.poses.append(action.poses.poses[0])
            self.add_subaction(a1,sim,plan,sub_action=True)
            a2 = Action(sim=Bool(sim))
            a2.type = a2.PLACE
            a2.item = a1.item
            a2.poses.header = action.poses.header
            a2.poses.poses.append(action.poses.poses[1])
            self.add_subaction(a2,sim,plan,sub_action=True)

        if action.type == action.RESET:
            move = Action(sim=Bool(sim))
            move.finished.data = False
            move.type = move.MOVE_ANGLE
            #ref_pose.pose.orientation = q
            #move.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move.joint_pose = [0., -0.5, 0., -1.8, 0., 1.31, 0.8]
            plan.append(move)

        if action.type == action.VIEW:
            move = Action(sim=Bool(sim))
            move.finished.data = False
            move.type = move.VIEW
            move.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            #Fix for non vertical objects
            #(trans,rot) = self._tl.lookupTransform("go_camera","camera1",rospy.Time(0))
            #move.pose.pose.position.x -= trans[0]
            #move.pose.pose.position.y -= trans[1]
            #move.pose.pose.position.z -= trans[2]
            #move.pose.pose.orientation = q
            plan.append(move)

        if action.type == action.MOVE:
            move = Action(sim=Bool(sim))
            move.finished.data = False
            move.type = move.MOVE
            move.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            #move.pose.pose.orientation = q
            plan.append(move)

        if action.type == action.PICK:
            #print("pick")
            move_above = Action(sim=Bool(sim))
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            if not sub_action:
                move_above.pose.pose.position.z+=.1
            move_to.pose.pose.position.z -= .003
            grasp = Action(sim=Bool(sim))
            grasp.finished.data = False
            grasp.type = grasp.GRASP
            grasp.item = action.item
            plan.append(move_above)
            plan.append(move_to)
            plan.append(grasp)
            plan.append(move_above)

        if action.type == action.INSPECT:
            #print("inspect")
            move_above = Action(sim=Bool(sim))
            move_above.finished.data = False
            move_above.type = move_above.VIEW
            move_above.poses = copy.deepcopy(action.poses)
            move_above.poses.poses[0].position.z += .35
            move_above.item = action.item
            self.add_subaction(move_above,sim,plan,sub_action=True)
            wait = Action(sim=Bool(sim))
            wait.finished.data = False
            wait.type = wait.WAIT
            wait.item = action.item
            plan.append(wait)
        
        if action.type == action.STOP:
            #print("stop")
            move = Action(sim=Bool(sim))
            move.finished.data = False
            move.type = move.MOVE
            move.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move.pose.pose.orientation = q
            plan.append(move)
        
        if action.type == action.PLACE:
            #print("place")
            move_above = Action(sim=Bool(sim))
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            if not sub_action:
                move_above.pose.pose.position.z+=.15
            move_prepare = copy.deepcopy(move_above)
            move_prepare.pose.pose.position.z-=.05
            move_to.type = move_to.INSERT
            move_to.pose.pose.position.z+=.01
            move_safe = copy.deepcopy(move_above)
            release = Action(sim=Bool(sim))
            release.finished.data = False
            release.type = release.RELEASE
            release.item = action.item
            plan.append(move_above)
            plan.append(move_prepare)
            plan.append(move_to)
            plan.append(release)
            plan.append(move_safe)

        if action.type == action.PUSH:
            # "Push"
            grasp = Action(sim=Bool(sim))
            grasp.finished.data = False
            grasp.type = grasp.GRASP
            grasp.item = String("none")
            move_above = Action(sim=Bool(sim))
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.15
            move_to.pose.pose.position.z+=.02
            move_safe = copy.deepcopy(move_above)
            release = Action(sim=Bool(sim))
            release.finished.data = False
            release.type = release.RELEASE
            release.item = String("none")
            plan.append(move_above)
            plan.append(grasp)
            plan.append(move_to)
            plan.append(move_safe)
            plan.append(release)
        
        if action.type == action.SCREW:
            #print("screw")
            #angle = 3*np.pi/5.
            angle = .95*np.pi/2.
            rot = tf.transformations.quaternion_from_euler(0,0,-angle)
            q_plus = Quaternion(rot[0],rot[1],rot[2],rot[3])
            rot = tf.transformations.quaternion_from_euler(0,0,angle)
            q_minus = Quaternion(rot[0],rot[1],rot[2],rot[3])
 
            move_above = Action(sim=Bool(sim))
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            move_to.pose.pose.position.z+=.005

            grasp = Action(sim=Bool(sim))
            grasp.finished.data = False
            grasp.type = grasp.GRASP
            grasp.item = action.item

            release = copy.deepcopy(grasp)
            release.type = release.RELEASE

            plus = copy.deepcopy(move_to)
            plus.pose.pose.position.z-=.002
            plus.pose.pose.orientation = q_plus
            minus = copy.deepcopy(move_to)
            minus.pose.pose.orientation = q_minus

            plan.append(move_above)
            plan.append(minus)
            plan.append(grasp)
            plan.append(plus)
            plan.append(release)
            plan.append(minus)
            plan.append(grasp)
            plan.append(plus)
            plan.append(release)
            plan.append(move_above)
        
        if action.type == action.UNSCREW:
            #print("unscrew")
            #angle = 3*np.pi/5.
            angle = .95*np.pi/2.
            rot = tf.transformations.quaternion_from_euler(0,0,-angle)
            q_plus = Quaternion(rot[0],rot[1],rot[2],rot[3])
            rot = tf.transformations.quaternion_from_euler(0,0,angle)
            q_minus = Quaternion(rot[0],rot[1],rot[2],rot[3])
 
            move_above = Action(sim=Bool(sim))
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            move_to.pose.pose.position.z-=.00

            grasp = Action(sim=Bool(sim))
            grasp.finished.data = False
            grasp.type = grasp.GRASP
            grasp.item = action.item

            release = copy.deepcopy(grasp)
            release.type = release.RELEASE

            plus = copy.deepcopy(move_to)
            plus.pose.pose.orientation = q_plus
            minus = copy.deepcopy(move_to)
            minus.pose.pose.orientation = q_minus
            minus.pose.pose.position.z+=.002

            plan.append(move_above)
            plan.append(plus)
            plan.append(grasp)
            plan.append(minus)
            plan.append(release)
            plan.append(plus)
            plan.append(grasp)
            plan.append(minus)
            plan.append(release)
            plan.append(move_above)

        if action.type == action.WIPE:
            max_off=.05
            p0 = action.poses.poses[0]
            p1 = action.poses.poses[1]
            p2 = action.poses.poses[2]
            p3 = action.poses.poses[3]

            move_above = Action(sim=Bool(sim))
            move_above.type = move_above.MOVE
            move_above.finished.data = False
            move_above.pose.pose = copy.deepcopy(p0)
            move_above.pose.pose.position.z+=.10
            plan.append(move_above)

            #distance of the left and right sides of the 'rectangle'
            d_l = self.get_distance(p0,p3)
            d_r = self.get_distance(p1,p2)
            #number of passes required to ensure that a side is wipped fully
            n_l = np.ceil(d_l/max_off)
            n_r = np.ceil(d_r/max_off)
            n = max(n_l,n_r)
            p_l=[]
            p_r=[]
            for i in range(int(n+1)):
                p_l.append(self.point_toward(p0,p3,i/n))
                p_r.append(self.point_toward(p1,p2,i/n))
            base_move = Action(sim=Bool(sim))
            base_move.type = base_move.MOVE_FORCE
            base_move.finished.data = False
            for i in range(int(n)):
                move = copy.deepcopy(base_move)
                if i == 0:
                    move.type = move.MOVE_TO_CONTACT
                move.pose = p_l[i] if not i%2 else p_r[i]
                plan.append(move)
                move = copy.deepcopy(base_move)
                move.pose = p_r[i] if not i%2 else p_l[i]
                plan.append(move)

            move_above = copy.deepcopy(move_above)
            move_above.pose = copy.deepcopy(move.pose)
            move_above.pose.pose.position.z += .10
            plan.append(move_above)
            release = Action(sim=Bool(sim))
            release.finished.data = False
            release.type = release.RELEASE
            release.item = String("none")
            plan.append(release)

        if not sub_action:
            #print(action)
            action.finished.data = True
            plan.append(action)

    def point_toward(self, p0, p1, ratio):
        p = PoseStamped()
        #Assume frame are in reference frame
        p.header.frame_id = REFERENCE_FRAME
        #Assume all points have same orientation
        p.pose.orientation = p0.orientation
        p.pose.position.x += p0.position.x + ratio * (p1.position.x-p0.position.x)
        p.pose.position.y += p0.position.y + ratio * (p1.position.y-p0.position.y)
        p.pose.position.z += p0.position.z + ratio * (p1.position.z-p0.position.z)
        return p

    def get_distance(self, p0, p1):
        return np.sqrt((p0.position.x-p1.position.x)**2+(p0.position.y-p1.position.y)**2+(p0.position.z-p1.position.z)**2)
        
    def get_type(self,action):
        if action.type == action.PICK:
            return "Pick"
        if action.type == action.SCREW:
            return "Tighten"
        if action.type == action.UNSCREW:
            return "Loosen"
        if action.type == action.PLACE:
            return "Place"
        if action.type == action.WIPE:
            return "Wipe"
        if action.type == action.MOVE:
            return "Move"
        if action.type == action.MOVE_TO_CONTACT:
            return "Move to"
        if action.type == action.GRASP:
            return "Grasp"
        if action.type == action.RELEASE:
            return "Release"
        if action.type == action.MOVE_OBJECT:
            return "Move"
        if action.type == action.VIEW:
            return "View"
        if action.type == action.INSPECT:
            return "Inspect"
        if action.type == action.MOVE_FORCE:
            return "Move force"
        if action.type == action.PUSH:
            return "Push"
        if action.type == action.INSERT:
            return "Insert"
        return ""

    def cancel_motion(self):
        if self._client.get_state() == CLIENT_ACTIVE:
            self._client.cancel_goal()
            print("waiting for cancelling")
            self._client.wait_for_result()
            print("done cancelling")

    def on_command(self,msg):
        self._pause = False
        self._type = msg.type
        starting = 0
        if msg.type == msg.SIM:
            self._sim = True
            self._event_pub.publish(String("start_sim"))
            plan = []
            self._current_action_progress = []
            for sub_action in msg.core_action:
                self.add_subaction(sub_action,SIM,plan)
            self._plan = plan
            self._running = True

        if msg.type == msg.VIZ:
            plan = []
            for sub_action in msg.core_action:
                self.add_subaction(sub_action,SIM,plan)
            self._plan = plan

        if msg.type == msg.EXEC:
            self._sim = False
            self._event_pub.publish(String("start_exec"))
            plan = []
            self._current_action_progress = []
            for sub_action in msg.core_action:
                self.add_subaction(sub_action,EXEC,plan)
            self._plan = plan
            self._running = True
                
        if msg.type == msg.EDIT:
            new_plan = []
            if len(msg.core_action) == 1:
                return
            for sub_action in msg.core_action:
                self.add_subaction(sub_action,self._plan[0].sim.data,new_plan)
            for action_done in self._current_action_progress:
                if action_done.type == new_plan[0].type and action_done.item == new_plan[0].item:
                    starting+=1
            self._plan = new_plan

        if msg.type != msg.VIZ or self._plan_following_thread.is_alive():
            self.cancel_motion()
        if msg.type != msg.VIZ:
            self._plan_following_thread = threading.Thread(target=self.run_plan, args=(starting,))
            self._plan_following_thread.start()
        #self.update_plan()

    def run_plan(self,starting):
        print("running plan")
        result = False

        for action in self._plan[starting:]:
            if action.finished.data:
                self._event_pub.publish(String("action_finished;"+self.get_type(action)+":"+action.item.data))
                continue
            goal = authoring_msgs.msg.AuthoringGoal()
            goal.goal = action
            self._client.send_goal(goal)
            print(self._client.wait_for_result())
            result = self._client.get_result().success.data
            if not result:
                break
            self._current_action_progress.append(action)

        if result:
            self._event_pub.publish(String("motion_finished"))

    def run(self):
        rospy.spin()

    def next_sub_action(self):
        if len(self._plan)>0 :
            self._plan.pop(0)
        
        if len(self._plan) == 0:
            return

        current_action = self._plan[0]
        if current_action.type == current_action.WAIT:
            self._event_pub.publish(String("wait;"+current_action.item.data))

        #print(len(self._plan))

    def action_finished(self,current_action):
        self._current_action_progress.append(current_action)
        self.next_sub_action()

    def update_plan(self):
        self.display_path()
        if not self._running or self._pause:
            return
        if len(self._plan) == 0:
            print("Finished")
            self._event_pub.publish(String("motion_finished"))
            self._running = False
            self._gripper_done = False
            self._gripper_acting = False
            return

        current_action = self._plan[0]
        #print(self.get_type(current_action))
        if current_action.finished.data:
            self._current_action_progress = []
            self._event_pub.publish(String("action_finished;"+self.get_type(current_action)+":"+current_action.item.data))
            self.next_sub_action()
            return
        if current_action.type == current_action.MOVE or current_action.type == current_action.INSERT or current_action.type == current_action.MOVE_FORCE:
            if self.go_to_position(current_action):
                self.action_finished(current_action)
                return

        if current_action.type == current_action.MOVE_ANGLE:
            if self.go_to_angle(current_action):
                self.action_finished(current_action)
                return
        if current_action.type == current_action.VIEW:
            self._camera_pub.publish(Bool(True))
            if self.view(current_action):
                self._camera_pub.publish(Bool(False))
                self.action_finished(current_action)
        if current_action.type == current_action.MOVE_TO_CONTACT:
            if self.go_to_position(current_action):
                self.action_finished(current_action)
        if current_action.type == current_action.GRASP:
            if self.grasp():
                self._event_pub.publish(String("grasped;"+current_action.item.data))
                self.action_finished(current_action)
        if current_action.type == current_action.RELEASE:
            if self.release():
                self._event_pub.publish(String("released;"+current_action.item.data))
                self.action_finished(current_action)
        if current_action.type == current_action.WAIT:
            if self._skip:
                print("skipping")
                #Finishing skipping action
                self._plan.pop(0)
                self._plan.pop(0)
                #Removing next action
                while not (self._plan[0].finished.data):
                    print("removing")
                    self._plan.pop(0)
                print("done skipping")
                self._skip = False
                return
            elif self._act:
                self._plan.pop(0)
                self.action_finished(current_action)
                self._act = False
            else:
                pass
                #self._event_pub.publish(String("wait;"+current_action.item.data))

    def bound(self, val, b):
        return min(max(val,-b),b)

    def vectorise(self, val):
        try:
            return [val.x, val.y, val.z, val.w]
        except:
            return [val.x, val.y, val.z]

    def insert(self, goal, dz):
        print("inserting")
        if self._inserting_factor == None:
            self._plan_z = dz
            self._inserting_factor = 0
        else:
            self._inserting_factor += 1
        
        n_turns = 10
        time = 10.
        sample_points = time*self._freq
        max_d = .01
        d_x = self._inserting_factor * np.cos(n_turns*2*np.pi*self._inserting_factor/sample_points)*max_d/sample_points
        d_y = self._inserting_factor * np.sin(n_turns*2*np.pi*self._inserting_factor/sample_points)*max_d/sample_points

        goal.header.stamp = rospy.Time.now()+rospy.Duration.from_sec(.050)
        goal.pose.position.x+=d_x
        goal.pose.position.y+=d_y
        self._goal_pub.publish(goal)        

    def go_to_angle(self, action):
        diff = []
        if self._current_joint is None:
            return False
        for i,joint in enumerate(action.joint_pose):
            diff.append(joint-self._current_joint.position[i])
        max_diff = max(diff,key=abs)
        threshold = .005
        print(self._angle_move)
        print(max_diff)
        if self._angle_move and np.fabs(max_diff) < threshold:
            self._angle_move = False
            return True
        if not self._angle_move:
            self._angle_move = True
            max_vel = .3
            d_t = np.fabs(max_diff)/max_vel

            pose = JointPose()
            pose.header.stamp = rospy.Time.now() + rospy.Duration(d_t)
            pose.joint_pose = action.joint_pose
            self._angle_pub.publish(pose)
        return False

    def view(self, action):
        goal = copy.deepcopy(action.pose)
        self._br.sendTransform(self.vectorise(goal.pose.position), self.vectorise(goal.pose.orientation), rospy.Time.now(), "cam_goal",REFERENCE_FRAME)
        try:
            cam_frame = "internal_rgb_camera_link"
            (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, cam_frame, rospy.Time(0))
        except:
            return
        pose = Pose()
        pose.position.x = goal.pose.position.x-trans[0]
        pose.position.y = goal.pose.position.y-trans[1]
        pose.position.z = goal.pose.position.z-trans[2]

        #From https://answers.ros.org/question/10124/relative-rotation-between-two-quaternions/
        qp = PyKDL.Rotation.Quaternion(rot[0],rot[1],rot[2],rot[3])
        current_angle = qp.GetRPY()

        rot = goal.pose.orientation
        qg = PyKDL.Rotation.Quaternion(rot.x,rot.y,rot.z,rot.w)
        q = qg*qp.Inverse()

        difference_angle = q.GetRPY()
        angle  = list(difference_angle) 

        threshold = .001
        dx = math.fabs(pose.position.x)
        dy = math.fabs(pose.position.y)
        dz = math.fabs(pose.position.z)

        if dx < threshold and dy < threshold and dz < threshold and math.fabs(angle[0])<.01 and math.fabs(angle[1])<.01:
            #Do something for x angle difference
            return True
            
        max_lin = .12
        max_rot = .6

        d = np.sqrt(dx**2+dy**2+dz**2)

        t_lin = d / max_lin
        t_rot = max([np.fabs(angle[0])/max_rot,np.fabs(angle[1])/max_rot])
    
        goal.header.stamp = rospy.Time.now()+rospy.Duration.from_sec(max(t_lin,t_rot))
        self._cam_goal_pub.publish(goal)
        return False

    def go_to_position(self, action):
        goal = HybridPose()
        if action.header.frame == REFERENCE_FRAME:
            goal.pose = copy.deepcopy(action.pose)
        else:
            print("--------------------------ERROR-----------------------------------")
            return
        goal.sel_vector = [1,1,1,0,0,0]
        goal.constraint_frame.w=1
        self._br.sendTransform(self.vectorise(goal.pose.position), self.vectorise(goal.pose.orientation), rospy.Time.now(), "current_goal",REFERENCE_FRAME)
        try:
            ee_frame = ('sim_' if self._sim else '') + 'end_effector'
            (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        except:
            return
        pose = Pose()
        pose.position.x = goal.pose.position.x-trans[0]
        pose.position.y = goal.pose.position.y-trans[1]
        pose.position.z = goal.pose.position.z-trans[2]

        #From https://answers.ros.org/question/10124/relative-rotation-between-two-quaternions/

        qp = PyKDL.Rotation.Quaternion(rot[0],rot[1],rot[2],rot[3])
        current_angle = qp.GetRPY()

        rot = goal.pose.orientation
        qg = PyKDL.Rotation.Quaternion(rot.x,rot.y,rot.z,rot.w)
        q = qg*qp.Inverse()

        difference_angle = q.GetRPY()
        angle  = list(difference_angle)

        d = current_angle[2] + difference_angle[2]
        if d > np.pi:
            angle[2] -= 2 * np.pi
        if d < -np.pi:
            angle[2] += 2 * np.pi 

        threshold = .001
        force_threshold = 4.
        dx = math.fabs(pose.position.x)
        dy = math.fabs(pose.position.y)
        dz = math.fabs(pose.position.z)

        if self._inserting_factor is not None:
            if (np.fabs(self._plan_z-dz)>5*threshold or dz<threshold):
                print("found hole")
                self._inserting_factor = None
                return True
            else:
                self.insert(goal,dz)
                return False

        if dx < threshold and dy < threshold and math.fabs(angle[0])<.1 and math.fabs(angle[1])<.1 and math.fabs(angle[2])<.1:
            if dz < threshold:
                print("arrived sub point")
                return True
            if np.fabs(self._force.z) > force_threshold:
                if (action.type == action.MOVE_TO_CONTACT or action.type == action.MOVE_FORCE):
                    print("found contact")
                    return True
                if action.type == action.INSERT:
                    print(np.fabs(self._force.z))
                    self.insert(goal,dz)
                    return False
        max_lin = .12
        if action.type == action.MOVE_TO_CONTACT or action.type == action.INSERT:
            max_lin = .05
            goal.sel_vector[2] = 0
        max_rot = .6

        d = np.sqrt(dx**2+dy**2+dz**2)

        if action.type == action.MOVE_FORCE:
            d = np.sqrt(dx**2+dy**2)

        t_lin = d / max_lin
        t_rot = max([np.fabs(angle[0])/max_rot,np.fabs(angle[1])/max_rot,np.fabs(angle[2])/max_rot])
    
        goal.header.stamp = rospy.Time.now()+rospy.Duration.from_sec(max(t_lin,t_rot))
        self._goal_pub.publish(goal)
        return False

    def normalise_angle(self, angle):
        return [(a+np.pi)%(2*np.pi)-np.pi for a in angle]

    def grasp(self):
        if self._gripper_done:
            self._gripper_done = False
            return True
        if not self._gripper_acting:
            cmd = String()
            cmd.data = "grasp"
            self._command_pub.publish(cmd)
            self._gripper_acting = True
        return False

    def release(self):
        if self._gripper_done:
            self._gripper_done = False
            return True
        if not self._gripper_acting:
            cmd = String()
            cmd.data = "release"
            self._command_pub.publish(cmd)
            self._gripper_acting = True
        return False

    def display_path(self):
        path = Path()
        path.header.frame_id = REFERENCE_FRAME
        ee_frame = 'sim_end_effector'
        (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        EE_pose = PoseStamped()
        EE_pose.pose.position.x = trans[0]
        EE_pose.pose.position.y = trans[1]
        EE_pose.pose.position.z = trans[2]
        EE_pose.pose.orientation.x = rot[0]
        EE_pose.pose.orientation.y = rot[1]
        EE_pose.pose.orientation.z = rot[2]
        EE_pose.pose.orientation.w = rot[3]
        EE_pose.header.frame_id = REFERENCE_FRAME
        path.poses = [EE_pose]
        for action in self._plan:
            if (action.type == action.MOVE or action.type == action.MOVE_FORCE or action.type == action.VIEW or action.type == action.MOVE_TO_CONTACT or action.type == action.INSERT) and not action.finished.data:
                path.poses.append(action.pose)
            else:
                pass
        self._path_pub.publish(path)

 

    def signal_handler(self, signal, frame):
        #publish empty path
        if self._plan_following_thread is not None:
            self._cl
        sys.exit(0)

if __name__ == "__main__":
    rospy.init_node("planner")
    planner = Planner()
    signal.signal(signal.SIGINT, planner.signal_handler)
    planner.run()

