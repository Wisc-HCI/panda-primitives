#!/usr/bin/env python
import rospy
import signal
import sys
import math
import tf
import PyKDL
import copy

from geometry_msgs.msg import Twist,Pose,PoseStamped,Quaternion
from nav_msgs.msg import Path
from std_msgs.msg import String
from authoring_msgs.msg import Action,Command

REFERENCE_FRAME='panda_link0'
ACTION_PICK=0
ACTION_PLACE=1

class Planner(object):
    def __init__(self):
        self._tl = tf.TransformListener()
        rospy.sleep(0.5) # sleep a bit to make sure the TF cache is filled
        self._path_pub = rospy.Publisher("/panda/path", Path, queue_size=0)
        self._vel_pub = rospy.Publisher("/panda/cart_vel",Twist, queue_size=5)
        self._command_sub = rospy.Subscriber("/planner/command", Command,self.on_command)
        self._string_pub = rospy.Publisher("/panda/commands",String, queue_size=1)
        self._plan = []
        self._running = False
        self._vel_pub.publish(Twist())

    def add_subaction(self, action):
        rot = tf.transformations.quaternion_from_euler(math.pi,0,0)
        q = Quaternion(rot[0],rot[1],rot[2],rot[3])
        if action.type == action.PICK:
            print "pick"
            move_above = Action()
            move_above.type = "motion"
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, action.pose)
            move_above.pose.pose.orientation = q
            move_safe = copy.deepcopy(move_above)
            move_safe.pose.pose.position.y = 0
            move_safe.pose.pose.position.z = .5
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            move_to.pose.pose.position.z-=.01
            grasp = Action()
            grasp.type="grasp"
            self._plan.append(move_safe)
            self._plan.append(move_above)
            self._plan.append(move_to)
            self._plan.append(grasp)
        
        if action.type == action.PLACE:
            print "place"
            move_above = Action()
            move_above.type = "motion"
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, action.pose)
            move_above.pose.pose.orientation = q
            move_safe = copy.deepcopy(move_above)
            move_safe.pose.pose.position.y = 0
            move_safe.pose.pose.position.z = .5
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            move_to.pose.pose.position.z+=.05
            release = Action()
            release.type="release"
            self._plan.append(move_safe)
            self._plan.append(move_above)
            self._plan.append(move_to)
            self._plan.append(release)
        
    def on_command(self,msg):
        print "new command"
        current_action_id = 0
        while len(msg.core_action)>0:
            print len(msg.core_action)
            current_action = []
            for sub_action in msg.core_action:
                if sub_action.id == current_action_id:
                    current_action.append(sub_action)
            current_action = sorted(current_action,key=lambda action: action.type)
            for sub_action in current_action:
                msg.core_action.remove(sub_action)
                self.add_subaction(sub_action)
            current_action_id += 1

        print "start plan"
        self._running = True
        self.update_plan()

    def run(self):
        r = rospy.Rate(100)
        while not rospy.is_shutdown():
            self.update_plan()
            r.sleep()

    def next_sub_action(self):
        self._plan.pop(0)
        self._vel_pub.publish(Twist())
        print len(self._plan)

    def update_plan(self):
        if not self._running:
            return
        if len(self._plan) == 0:
            print "Finished"
            self._running = False
            return

        current_action = self._plan[0]
        if current_action.type == 'motion':
            if self.go_to_position(current_action.pose):
                self.next_sub_action()
        if current_action.type == 'grasp':
            if self.grasp():
                self.next_sub_action()
        if current_action.type == 'release':
            if self.release():
                self.next_sub_action()

    def bound(self, val, b):
        return min(max(val,-b),b)

    def go_to_position(self, goal):
        try:
            (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, 'end_effector', rospy.Time(0))
        except:
            print("fail")
            return

        pose = Pose()
        pose.position.x = goal.pose.position.x-trans[0]
        pose.position.y = goal.pose.position.y-trans[1]
        pose.position.z = goal.pose.position.z-trans[2]

        #From https://answers.ros.org/question/10124/relative-rotation-between-two-quaternions/
        qp = PyKDL.Rotation.Quaternion(rot[0],rot[1],rot[2],rot[3])

        rot = goal.pose.orientation
        qg = PyKDL.Rotation.Quaternion(rot.x,rot.y,rot.z,rot.w)
        q = qg*qp.Inverse()

        angle = q.GetRPY()

        threshold = .01
        if math.fabs(pose.position.x) < threshold and math.fabs(pose.position.y) < threshold and math.fabs(pose.position.z) <threshold:
            print "arrived sub point"
            return True
        else:
            twist = Twist()
            max_vel = .15
            P=8
            twist.linear.x=self.bound(P*pose.position.x,max_vel)
            twist.linear.y=self.bound(P*pose.position.y,max_vel)
            twist.linear.z=self.bound(P*pose.position.z,max_vel)
            twist.angular.x=self.bound(angle[0],max_vel)
            twist.angular.y=self.bound(angle[1],max_vel)
            twist.angular.z=self.bound(angle[2],max_vel)
            self._vel_pub.publish(twist)
        return False

    def grasp(self):
        cmd = String()
        cmd.data = "toggleGrip"
        self._string_pub.publish(cmd)
        rospy.sleep(1)
        return True

    def release(self):
        cmd = String()
        cmd.data = "toggleGrip"
        self._string_pub.publish(cmd)
        rospy.sleep(1)
        return True

    def display_path(self):
        path = Path()
        path.header.frame_id = REFERENCE_FRAME
        (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, 'end_effector', rospy.Time(0))
        EE_pose = PoseStamped()
        EE_pose.pose.position.x = trans[0]
        EE_pose.pose.position.y = trans[1]
        EE_pose.pose.position.z = trans[2]
        EE_pose.pose.orientation.x = rot[0]
        EE_pose.pose.orientation.y = rot[1]
        EE_pose.pose.orientation.z = rot[2]
        EE_pose.pose.orientation.w = rot[3]
        EE_pose.header.frame_id = REFERENCE_FRAME
        path.poses = [EE_pose]
        for i in self._goals:
            path.poses.append(i)
        self._path_pub.publish(path)

 

    def signal_handler(self, signal, frame):
        #publish empty path
        self._vel_pub.publish(Twist())
        sys.exit(0)

if __name__ == "__main__":
    rospy.init_node("planner")
    planner = Planner()
    signal.signal(signal.SIGINT, planner.signal_handler)
    planner.run()

