#!/usr/bin/env python
import rospy
import signal
import sys
import math
import tf
import PyKDL
import copy
import numpy as np

from geometry_msgs.msg import Twist,Pose,PoseStamped,Quaternion,Vector3,Wrench
from nav_msgs.msg import Path
from std_msgs.msg import String, Bool
from authoring_msgs.msg import Action,Command

REFERENCE_FRAME='panda_link0'
ACTION_PICK=0
ACTION_PLACE=1

class Planner(object):
    def __init__(self):
        self._tl = tf.TransformListener()
        self._br = tf.TransformBroadcaster()
        rospy.sleep(2.5) # sleep a bit to make sure the TF cache is filled
        self._path_pub = rospy.Publisher("/planner/path", Path, queue_size=0)
        self._vel_pub = rospy.Publisher("/planner/cart_vel", Twist, queue_size=5)
        self._command_sub = rospy.Subscriber("/parser/command", Command, self.on_command)
        self._event_pub = rospy.Publisher("/event",String,queue_size = 5)
        self._command_pub = rospy.Publisher("/planner/command", String, queue_size=1)
        self._force_sub = rospy.Subscriber("/panda/wrench", Wrench, self.on_force)
        self._plan = []
        self._running = False
        self._vel_pub.publish(Twist())
        self._sim = False
        self._integrator = Twist()
        self._freq = 100.
        self._force = Vector3()

    def on_force(self, msg):
        self._force = msg.force

    def add_subaction(self, action):
        rot = tf.transformations.quaternion_from_euler(0,0,0)
        ref_pose = PoseStamped()
        ref_pose.header = action.poses.header
        ref_pose.pose = action.poses.poses[0]
        q = Quaternion(rot[0],rot[1],rot[2],rot[3])
        if action.type == action.PICK:
            print "pick"
            move_above = Action()
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.1
            move_to.pose.pose.position.z
            grasp = Action()
            grasp.finished.data = False
            grasp.type = grasp.GRASP
            self._plan.append(move_above)
            self._plan.append(move_to)
            self._plan.append(grasp)
            self._plan.append(move_above)
        
        if action.type == action.PLACE:
            print "place"
            move_above = Action()
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.15
            move_to.pose.pose.position.z+=.02
            move_safe = copy.deepcopy(move_above)
            release = Action()
            release.finished.data = False
            release.type = release.RELEASE
            self._plan.append(move_above)
            self._plan.append(move_to)
            self._plan.append(release)
            self._plan.append(move_safe)
        
        if action.type == action.SCREW:
            print "screw"
            #angle = 3*np.pi/5.
            angle = 1.2*np.pi/2.
            rot = tf.transformations.quaternion_from_euler(0,0,-angle)
            q_plus = Quaternion(rot[0],rot[1],rot[2],rot[3])
            rot = tf.transformations.quaternion_from_euler(0,0,angle)
            q_minus = Quaternion(rot[0],rot[1],rot[2],rot[3])
 
            move_above = Action()
            move_above.finished.data = False
            move_above.type = move_above.MOVE
            move_above.pose = self._tl.transformPose(REFERENCE_FRAME, ref_pose)
            move_above.pose.pose.orientation = q
            move_to = copy.deepcopy(move_above)
            move_above.pose.pose.position.z+=.15
            move_to.pose.pose.position.z+=.13

            plus_high = copy.deepcopy(move_above)
            plus_high.pose.pose.orientation = q_plus
            minus_high = copy.deepcopy(move_above)
            minus_high.pose.pose.orientation = q_minus

            plus_low = copy.deepcopy(move_to)
            plus_low.pose.pose.orientation = q_plus
            minus_low = copy.deepcopy(move_to)
            minus_low.pose.pose.orientation = q_minus
            plus_low2 = copy.deepcopy(plus_low)
            plus_low2.pose.pose.position.z-=.003

            minus_low2 = copy.deepcopy(minus_low)
            minus_low2.pose.pose.position.z-=.003

            self._plan.append(move_above)
            self._plan.append(minus_high)
            self._plan.append(minus_low)
            self._plan.append(plus_low)
            self._plan.append(plus_high)
            self._plan.append(minus_high)
            self._plan.append(minus_low2)
            self._plan.append(plus_low2)
            self._plan.append(plus_high)
            self._plan.append(move_above)
        if action.type == action.WIPE:
            max_off=.05
            p0 = action.poses.poses[0]
            p1 = action.poses.poses[1]
            p2 = action.poses.poses[2]
            p3 = action.poses.poses[3]

            move_above = Action()
            move_above.type = move_above.MOVE
            move_above.finished.data = False
            move_above.pose.pose = copy.deepcopy(p0)
            move_above.pose.pose.position.z+=.10
            self._plan.append(move_above)

            #distance of the left and right sides of the 'rectangle'
            d_l = self.get_distance(p0,p3)
            d_r = self.get_distance(p1,p2)
            #number of passes required to ensure that a side is wipped fully
            n_l = np.ceil(d_l/max_off)
            n_r = np.ceil(d_r/max_off)
            n = max(n_l,n_r)
            p_l=[]
            p_r=[]
            for i in range(int(n+1)):
                p_l.append(self.point_toward(p0,p3,i/n))
                p_r.append(self.point_toward(p1,p2,i/n))
            move = Action()
            move.type = move.MOVE_TO_CONTACT
            move.finished.data = False
            for i in range(int(n)):
                move = copy.deepcopy(move)
                move.pose = p_l[i] if not i%2 else p_r[i]
                self._plan.append(move)
                move = copy.deepcopy(move)
                move.pose = p_r[i] if not i%2 else p_l[i]
                self._plan.append(move)

            move_above = copy.deepcopy(move_above)
            move_above.pose = copy.deepcopy(move.pose)
            move_above.pose.pose.position.z += .10
            self._plan.append(move_above)



        action.finished.data = True
        self._plan.append(action)

    def point_toward(self, p0, p1, ratio):
        p = PoseStamped()
        #Assume frame are in reference frame
        p.header.frame_id = REFERENCE_FRAME
        #Assume all points have same orientation
        p.pose.orientation = p0.orientation
        p.pose.position.x += p0.position.x + ratio * (p1.position.x-p0.position.x)
        p.pose.position.y += p0.position.y + ratio * (p1.position.y-p0.position.y)
        p.pose.position.z += p0.position.z + ratio * (p1.position.z-p0.position.z)
        return p



    def get_distance(self, p0, p1):
        return np.sqrt((p0.position.x-p1.position.x)**2+(p0.position.y-p1.position.y)**2+(p0.position.z-p1.position.z)**2)
        
    def get_type(self,action):
        if action.type == action.PICK:
            return "Pick"
        if action.type == action.SCREW:
            return "Screw"
        if action.type == action.PLACE:
            return "Place"
        if action.type == action.WIPE:
            return "Wipe"
        if action.type == action.MOVE:
            return "Move"
        if action.type == action.MOVE_TO_CONTACT:
            return "Move"
        if action.type == action.GRASP:
            return "Grasp"
        if action.type == action.RELEASE:
            return "Release"
        return ""

    def on_command(self,msg):
        print "new command"
        self._plan = []
        current_action_id = 0
        self._type = msg.type
        for sub_action in msg.core_action:
            self.add_subaction(sub_action)

        if msg.type == msg.SIM:
            self._sim = True
            self._event_pub.publish(String("start_sim"))
            self._running = True
            rospy.sleep(.05)
        if msg.type == msg.EXEC:
            self._sim = False
            self._event_pub.publish(String("start_exec"))
            self._running = True
        self.update_plan()

    def run(self):
        r = rospy.Rate(self._freq)
        while not rospy.is_shutdown():
            self.update_plan()
            r.sleep()

    def next_sub_action(self):
        self._plan.pop(0)
        self._vel_pub.publish(Twist())
        print len(self._plan)


    def update_plan(self):
        print "in plan"
        self.display_path()
        if not self._running:
            return
        if len(self._plan) == 0:
            print "Finished"
            self._event_pub.publish(String("motion_finished"))

            self._running = False
            return

        current_action = self._plan[0]
        if current_action.finished.data:
            self._event_pub.publish(String("action_finished;"+self.get_type(current_action)+":"+current_action.item.data))
            self.next_sub_action()
        if current_action.type == current_action.MOVE:
            if self.go_to_position(current_action.pose):
                self.next_sub_action()
        if current_action.type == current_action.MOVE_TO_CONTACT:
            if self.go_to_position(current_action.pose, contact = True):
                self.next_sub_action()
        if current_action.type == current_action.GRASP:
            if self.grasp():
                self.next_sub_action()
        if current_action.type == current_action.RELEASE:
            if self.release():
                self.next_sub_action()

    def bound(self, val, b):
        return min(max(val,-b),b)

    def vectorise(self, val):
        try:
            return [val.x, val.y, val.z, val.w]
        except:
            return [val.x, val.y, val.z]

    def go_to_position(self, goal, contact = False):
        self._br.sendTransform(self.vectorise(goal.pose.position), self.vectorise(goal.pose.orientation), rospy.Time.now(), "current_goal",REFERENCE_FRAME)
        try:
            ee_frame = ('sim_' if self._sim else '') + 'end_effector'
            print ee_frame
            (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        except:
            print("fail")
            return
        pose = Pose()
        pose.position.x = goal.pose.position.x-trans[0]
        pose.position.y = goal.pose.position.y-trans[1]
        pose.position.z = goal.pose.position.z-trans[2]

        #From https://answers.ros.org/question/10124/relative-rotation-between-two-quaternions/

        qp = PyKDL.Rotation.Quaternion(rot[0],rot[1],rot[2],rot[3])
        current_angle = qp.GetRPY()

        rot = goal.pose.orientation
        qg = PyKDL.Rotation.Quaternion(rot.x,rot.y,rot.z,rot.w)
        q = qg*qp.Inverse()

        difference_angle = q.GetRPY()
        angle  = list(difference_angle)
        d = current_angle[2] + difference_angle[2]
        if d > np.pi:
            angle[2] -= 2 * np.pi
        if d < -np.pi:
            angle[2] += 2 * np.pi 

        threshold = .005
        force_threshold = 20.
        dx = math.fabs(pose.position.x)
        dy = math.fabs(pose.position.y)
        dz = math.fabs(pose.position.z)

        if dx < threshold and dy < threshold and (dz <threshold or (contact and np.fabs(self._force.z) > force_threshold)) and math.fabs(angle[0])<.1 and math.fabs(angle[1])<.1 and math.fabs(angle[2])<.1:
            print "arrived sub point"
            return True
        else:
            twist = Twist()
            max_vel = .10
            P_lin=8 if not contact else 2
            P_rot=8
            I=0.000
            if dx < 5 * threshold and dx > threshold/2 and pose.position.x*self._integrator.linear.x >= 0:
                print "filling x"
                self._integrator.linear.x += pose.position.x
            else:
                self._integrator.linear.x = 0
            print "new"
            print dx
            if dy < 5 * threshold and dy > threshold/2 and pose.position.y*self._integrator.linear.y >= 0:
                print "filling y"
                self._integrator.linear.y += pose.position.y
            else:
                self._integrator.linear.y = 0
            print dy
            if dz < 5 * threshold and dz > threshold/2 and pose.position.z*self._integrator.linear.z >= 0:
                print "filling z"
                self._integrator.linear.z += pose.position.z
            else:
                self._integrator.linear.z = 0
            print dz

            twist.linear.x=self.bound(P_lin*pose.position.x+I*self._integrator.linear.x,max_vel)
            twist.linear.y=self.bound(P_lin*pose.position.y+I*self._integrator.linear.y,max_vel)
            twist.linear.z=self.bound(P_lin*pose.position.z+I*self._integrator.linear.z,max_vel)

            print self._integrator.linear.z

            twist.angular.x=self.bound(P_rot*angle[0],6*max_vel)
            twist.angular.y=self.bound(P_rot*angle[1],6*max_vel)
            twist.angular.z=self.bound(P_rot*angle[2],6*max_vel)
            self._vel_pub.publish(twist)
        return False

    def normalise_angle(self, angle):
        return [(a+np.pi)%(2*np.pi)-np.pi for a in angle]

    def grasp(self):
        v = Twist()
        self._vel_pub.publish(v)
        cmd = String()
        cmd.data = "grasp"
        self._command_pub.publish(cmd)
        rospy.sleep(2)
        return True

    def release(self):
        v = Twist()
        self._vel_pub.publish(v)
        cmd = String()
        cmd.data = "release"
        self._command_pub.publish(cmd)
        rospy.sleep(1)
        return True

    def display_path(self):
        path = Path()
        path.header.frame_id = REFERENCE_FRAME
        ee_frame = 'sim_end_effector'
        (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        EE_pose = PoseStamped()
        EE_pose.pose.position.x = trans[0]
        EE_pose.pose.position.y = trans[1]
        EE_pose.pose.position.z = trans[2]
        EE_pose.pose.orientation.x = rot[0]
        EE_pose.pose.orientation.y = rot[1]
        EE_pose.pose.orientation.z = rot[2]
        EE_pose.pose.orientation.w = rot[3]
        EE_pose.header.frame_id = REFERENCE_FRAME
        path.poses = [EE_pose]
        print len(self._plan)
        for action in self._plan:
            print action.type
            if (action.type == action.MOVE or action.type == action.MOVE_TO_CONTACT) and not action.finished.data:
                path.poses.append(action.pose)
        self._path_pub.publish(path)

 

    def signal_handler(self, signal, frame):
        #publish empty path
        self._vel_pub.publish(Twist())
        sys.exit(0)

if __name__ == "__main__":
    rospy.init_node("planner")
    planner = Planner()
    signal.signal(signal.SIGINT, planner.signal_handler)
    planner.run()

