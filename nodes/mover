#!/usr/bin/env python
import rospy
import signal
import sys
import math
import tf
import PyKDL

from geometry_msgs.msg import Twist,Pose,PoseStamped
from std_msgs.msg import String
from nav_msgs.msg import Path
from relaxed_ik.msg  import EEPoseGoals,JointAngles
from sensor_msgs.msg import JointState

import numpy as np 

REFERENCE_FRAME='rel_ik_zero'

class Mover(object):
    def __init__(self):
        self._tl = tf.TransformListener()
        self._br = tf.TransformBroadcaster()
        rospy.sleep(1.) # sleep a bit to make sure the TF cache is filled
        self._twist_sub = rospy.Subscriber("/planner/cart_vel",Twist, self.on_velocity)
        self._command_sub = rospy.Subscriber("/planner/command", String, self.on_command)
        self._command_pub = rospy.Publisher("/panda/command", String, queue_size=1)
        self._event_sub = rospy.Subscriber("/event",String, self.on_event)
        self._goal_pub = rospy.Publisher("/relaxed_ik/ee_pose_goals", EEPoseGoals, queue_size=1)
        self._angle_sub = rospy.Subscriber("/relaxed_ik/joint_angle_solutions", JointAngles, self.on_solution, queue_size=1)
        self._joint_commands_pub = rospy.Publisher("/panda/joint_angle", JointAngles, queue_size = 5)
        #self._gui_sub = rospy.Subscriber("/gui/command", String, self.on_command)
        self._sim = True
        self._exec = False
        self._target_vel = None
        self._freq = 50.

    def run(self):
        r = rospy.Rate(self._freq)
        while not rospy.is_shutdown():
            self.move()
            r.sleep()

    def on_command(self, msg):
        if self._exec:
            self._command_pub.publish(msg)

    def on_event(self, msg):
        cmd = msg.data.split(";")[0] 
        if cmd == "motion_finished":
            self._sim = False
            self._exec = False
        if cmd == "start_sim":
            self._sim = True
            self._exec = False
        if cmd == "start_exec":
            self._sim = False
            self._exec = True
 
    def on_velocity(self, msg):
        self._target_vel = msg
    
    def on_solution(self, msg):
        if not self._sim and self._exec:
            self._joint_commands_pub.publish(msg)

    def on_command(self, msg):
        commands = msg.data.split(";")
        if commands[0] == "exec":
            self._sim == False
            self._exec = True
        if commands[0] == "sim":
            self._sim = True
            self._sim = False
        
    def signal_handler(self, signal, frame):
        sys.exit(0)

    def get_lin_magnitude(self, vel):
        return np.sqrt(vel.linear.x**2 + vel.linear.y**2 + vel.linear.z**2)

    def get_ang_magnitude(self, vel):
        return np.sqrt(vel.angular.x**2 + vel.angular.y**2 + vel.angular.z**2)

    def move(self):
        if self._target_vel is None or (self.get_lin_magnitude(self._target_vel) < .00000001 and self.get_ang_magnitude(self._target_vel) < .00000001):
            print "vel 0 requested"
            return
        ee_frame = ('sim_' if self._sim else '') + 'end_effector'
        (trans,rot) = self._tl.lookupTransform(REFERENCE_FRAME, ee_frame, rospy.Time(0))

        print "current pose"
        print trans
        print "vel"
        print self._target_vel.linear
        factor = self._freq
        trans[0] += self._target_vel.linear.x/factor
        trans[1] += self._target_vel.linear.y/factor
        trans[2] += self._target_vel.linear.z/factor
        print "target"
        print trans

        angle = list(tf.transformations.euler_from_quaternion(rot))

        angle[0] += self._target_vel.angular.x/factor
        angle[1] += self._target_vel.angular.y/factor
        angle[2] += self._target_vel.angular.z/factor
        rot = list(tf.transformations.quaternion_from_euler(angle[0],angle[1],angle[2]))
        goal = EEPoseGoals()
        goal.header.frame_id = REFERENCE_FRAME
        pose = Pose()
        pose.position.x=trans[0]
        pose.position.y=trans[1]
        pose.position.z=trans[2]
        pose.orientation.x=rot[0]
        pose.orientation.y=rot[1]
        pose.orientation.z=rot[2]
        pose.orientation.w=rot[3]
        goal.ee_poses.append(pose)
        self._goal_pub.publish(goal)
        self._br.sendTransform(trans, rot, rospy.Time.now(), "target",REFERENCE_FRAME)

if __name__ == "__main__":
    rospy.init_node("mover")
    mover = Mover()
    signal.signal(signal.SIGINT, mover.signal_handler)
    mover.run()

