#! /usr/bin/env python3
import rospy
import actionlib
import authoring_msgs.msg
from panda_ros_msgs.msg import HybridPose, JointPose
from geometry_msgs.msg import PoseStamped, Pose, Wrench, TwistStamped
from std_msgs.msg import Bool, String
from sensor_msgs.msg import JointState
import tf
import tf2_ros
import tf2_geometry_msgs
import PyKDL
import numpy as np
from scipy.spatial.transform import Rotation as R
from scipy.spatial.transform import Slerp
import random

import copy

REFERENCE_FRAME = "panda_link0"

class AuthoringAction(object):

    def __init__(self, name):
        self._action_name = name
        self._freq = 1000
        self._tfBuffer = tf2_ros.Buffer()
        self._tl = tf2_ros.TransformListener(self._tfBuffer)
        rospy.sleep(.5)
        self._br = tf2_ros.TransformBroadcaster()
        self._current_action = None
        self._starting_time = None
        self._starting_pose = None
        self._waiting_for = None
        self._wrench = Wrench()
        self._search_theta = 0
        self._searching = False
        self._push_force = -10
        self._insert_progress = 0
        self._angle_move = False
        self._found_hole = False
        self._z_plane = None
        self._current_joint = None
        self._virtual = rospy.get_param('~only_virtual')
        #TODO To fix
        self._angle_time = rospy.Time.now()
        self._as = actionlib.SimpleActionServer(self._action_name, authoring_msgs.msg.AuthoringAction, execute_cb=self.execute_cb, auto_start = False)
        self._as.start()
        # create messages that are used to publish feedback/result
        self._feedback = authoring_msgs.msg.AuthoringFeedback()
        self._result = authoring_msgs.msg.AuthoringResult()
        self._pose_pub = rospy.Publisher("/panda/hybrid_pose", HybridPose, queue_size=5)
        self._command_pub = rospy.Publisher("/panda/commands", String, queue_size=5)
        self._event_sub = rospy.Subscriber("/panda/events", String, self.on_event)
        self._wrench_sub = rospy.Subscriber("/panda/control_wrench", Wrench, self.on_wrench)
        
        self._panda_angle_sub = rospy.Subscriber("/panda/joint_states", JointState, self.on_state, queue_size=1)
        self._angle_pub = rospy.Publisher("/panda/joint_pose", JointPose, queue_size = 5)
        self._cart_vel_pub = rospy.Publisher("/panda/cart_velocity", TwistStamped, queue_size = 5)

        self._event_pub = rospy.Publisher("/event",String,queue_size = 5)

        # Simulator
        self._sim_angle_sub = rospy.Subscriber("/simulator/joint_states", JointState, self.on_sim_state, queue_size=1)
        self._sim_angle_pub = rospy.Publisher("/simulator/joint_pose", JointPose, queue_size = 5)
        self._sim_command_pub = rospy.Publisher("/simulator/commands", String, queue_size=5)
        self._sim_pose_pub = rospy.Publisher("/simulator/hybrid_pose", HybridPose, queue_size=5)
        self._sim_event_sub = rospy.Subscriber("/simulator/events", String, self.on_sim_event)

        # Camera Control
        self._chain_pub = rospy.Publisher("/panda/set_kinematic_chain", String, queue_size=2)
        self._link_pub = rospy.Publisher("/panda/set_ee_link", String, queue_size=2)

        self._camera_control = False
        self._velocity_sent = False
        
        # Lambda for event
        self._on_success = None

    def on_state(self, msg):
        self._current_joint = msg

    def on_sim_state(self, msg):
        if self._virtual or (self._current_action is not None and self._current_action.sim.data):
            self._current_joint = msg

    def on_event(self, msg):
        if msg.data == self._waiting_for:
            self.success()

    def on_sim_event(self, msg):
        if msg.data == self._waiting_for:
            self.success()

    def on_wrench(self,msg):
        self._wrench = msg

    def execute_cb(self, goal):
        #while(not self._as.is_preempt_requested()):
        #    print("running")
        #    rospy.sleep(1)
        #print("stopped")
        #if self._as.is_preempt_requested():
        #    self._result.success = Bool(False)
        #    self._as.set_succeeded(self._result)
        #return
        self._current_action = None
        self._angle_move = None
        self._waiting_for = None
        self._on_success = None
        self._searching = False
        self._found_hole = False
        self._z_plane = None
        self._starting_time = rospy.Time.now()
        self._velocity_sent = False
        if goal.goal.type != goal.goal.VIEW and goal.goal.type != goal.goal.CAMERA_VELOCITY:
            if self._camera_control:
                self.camera_control(False)
            self._starting_pose = self.get_pose_from_trans(self._tfBuffer.lookup_transform("panda_link0", "end_effector", rospy.Time(0)))
        else:
            self._starting_pose = self.get_pose_from_trans(self._tfBuffer.lookup_transform("panda_link0", "rotated_camera", rospy.Time(0)))

        # WHY?
        #if goal.goal.type == goal.goal.MOVE_FORCE:
        #    goal.goal.pose.pose.position.z = self._starting_pose.pose.position.z
        goal.goal.pose.header.stamp = self._starting_time + rospy.Duration(self.get_time_between_pose(self._starting_pose.pose, goal.goal.pose.pose))
        self._current_action = goal.goal

        r = rospy.Rate(self._freq)
        while not rospy.is_shutdown() and self._current_action is not None:
            if self._as.is_preempt_requested():
                self.success(False)
                return
            self.update_command()
            r.sleep()

    def update_command(self):
        if self._current_action and (self._current_action.type == self._current_action.MOVE or self._current_action.type == self._current_action.STOP):
            if self.go_to_position():
                self.success()
        elif self._current_action.type == self._current_action.GRASP:
            self.grasp()
        elif self._current_action.type == self._current_action.RELEASE:
            self.release()
        elif self._current_action.type == self._current_action.VIEW:
            if self.view():
                self.success()
        elif self._current_action.type == self._current_action.PULL:
            if self.pull():
                self.success()
        elif self._current_action.type == self._current_action.MOVE_FORCE:
            if self.move_force():
                self.success()
        elif self._current_action.type == self._current_action.INSERT:
            if self.insert():
                self.success()
        elif self._current_action.type == self._current_action.CAMERA_VELOCITY:
            if self.camera_velocity():
                self.success()
        elif self._current_action.type == self._current_action.MOVE_ANGLE:
            if self.go_to_angle():
                self.success()
    
    def grasped(self):
        self._event_pub.publish(String("grasped;"+self._current_action.item.data))
        self._cart_vel_pub.publish(TwistStamped())

    def released(self):
        self._event_pub.publish(String("released;"+self._current_action.item.data))
        self._cart_vel_pub.publish(TwistStamped())

    def grasp(self):
        if self._waiting_for is None:
            h = HybridPose()
            h.constraint_frame.w = 1
            h.sel_vector=[0,0,0,0,0,0]
            self._pose_pub.publish(h)
            self._waiting_for = "grasp_finished"
            if self._virtual or self._current_action.sim.data:
                self._sim_command_pub.publish("grasp")
            else:
                self._command_pub.publish("grasp")
            self._on_success = self.grasped

    def release(self):
        if self._waiting_for is None:
            h = HybridPose()
            h.constraint_frame.w = 1
            h.sel_vector=[0,0,0,0,0,0]
            self._pose_pub.publish(h)
            self._waiting_for = "release_finished"
            if self._virtual or self._current_action.sim.data:
                self._sim_command_pub.publish("release")
            else:
                self._command_pub.publish("release")
            self._on_success = self.released

    def go_to_angle(self):
        if self._current_joint is None:
            return False
        diff = []
        for i,joint in enumerate(self._current_action.joint_pose):
            diff.append(joint-self._current_joint.position[i])
        max_diff = max(diff,key=abs)
        threshold = .005
        if self._angle_move and (np.fabs(max_diff) < threshold or rospy.Time.now() > self._angle_time) :
            self._angle_move = False
            return True
        if not self._angle_move:
            self._angle_move = True
            max_vel = .3
            d_t = np.fabs(max_diff)/max_vel

            pose = JointPose()
            self._angle_time = rospy.Time.now() + rospy.Duration(d_t)
            pose.header.stamp = self._angle_time
            pose.joint_pose = self._current_action.joint_pose
            if self._virtual or self._current_action.sim.data:
                self._sim_angle_pub.publish(pose)
            else:
                self._angle_pub.publish(pose)
        return False

    def insert(self):
        ee_frame = ('sim_' if self._current_action.sim.data else '') + 'end_effector'
        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        linear,_ = self.get_diff_pose_trans(self._current_action.pose.pose,t)

        linear_threshold = .001
        if np.fabs(linear[2]) < linear_threshold:
            return True

        action = self._current_action
        coils = 10
        radius = .03
        v=.02#cm/s
        theta_max = 2*np.pi*coils
        step = radius/theta_max
        chord = v/self._freq
        
        force = self._push_force/2
        force_contact = force*.9
        force_hole = force*.7

        away = step*self._search_theta
        d_x = np.cos(self._search_theta)*away
        d_y = np.sin(self._search_theta)*away
        # To test, previous code
        # if self._search_theta == 0:
        #     self._search_theta = chord/step
        # 
        # force_threshold = self._push_force*.7
        # 
        # away = step*self._search_theta
        # d_x = np.cos(self._search_theta)*away
        # d_y = np.sin(self._search_theta)*away
        # if self._wrench.force.z < force_threshold:
        #     self._search_theta+=chord/away

        pose = HybridPose()
        pose.pose.position.x = action.pose.pose.position.x+d_x
        pose.pose.position.y = action.pose.pose.position.y+d_y
        pose.pose.orientation.w = 1
        pose.sel_vector=[1,1,0,0,0,0]
        pose.wrench.force.x = 0
        pose.wrench.force.y = 0
        pose.wrench.force.z = force
        pose.constraint_frame.w = 1
        print("Force")
        print(self._wrench.force.z)
        print(force_contact)
        if self._wrench.force.z < force_contact:
            if self._z_plane is None:
                self._z_plane = t.transform.translation.z
            if self._search_theta == 0:
                self._search_theta = chord/step
            else:
                self._search_theta+=chord/away
            print("High force")
        else:
            if self._wrench.force.z < force_hole:
                print("Medium force")
            else: 
                print("Low force")
        if self._z_plane is not None and (self._z_plane - t.transform.translation.z > .002):
            self._found_hole = True
            pose.sel_vector=[0,0,0,0,0,0]
            pose.wrench.force.z *= 2
            print("found_hole")        

        
        if self._virtual or self._current_action.sim.data:
            self._sim_pose_pub.publish(pose)
        else:
            self._pose_pub.publish(pose)
        return False

    def move_force(self):
        self._reached_position = False
        action = self._current_action
        goal = HybridPose()
        goal.sel_vector = [1,1,0,0,0,0]
        goal.constraint_frame.w=1

        ee_frame = ('sim_' if action.sim.data else '') + 'end_effector'
        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        linear,angular = self.get_diff_pose_trans(action.pose.pose,t)
        
        linear_threshold = .001
        angular_threshold = .01
        
        if np.all(np.abs(linear)<linear_threshold) and np.all(np.abs(angular)<angular_threshold):
            self._reached_position = True
            return True
        linear[2] = 0
        force_threshold = self._push_force*.7
        if np.all(np.abs(linear)<linear_threshold) and np.all(np.abs(angular)<angular_threshold) and self._wrench.force.z < force_threshold:
            return True
        progress = min((rospy.Time.now() - self._starting_time).to_sec()/(action.pose.header.stamp - self._starting_time).to_sec(),1)
        goal.pose = self.interpolate_poses(self._starting_pose.pose, action.pose.pose,progress)
        goal.wrench.force.z = self._push_force
        
        if self._virtual or self._current_action.sim.data:
            self._sim_pose_pub.publish(goal)
        else:
            self._pose_pub.publish(goal)
        
        return False

    def pull(self):
        action = self._current_action
        goal = HybridPose()
        goal.sel_vector = [0,0,0,0,0,0]
        goal.constraint_frame.w=1

        ee_frame = ('sim_' if action.sim.data else '') + 'end_effector'
        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        linear,angular = self.get_diff_pose_trans(action.pose.pose,t)
        
        linear_threshold = .001
        angular_threshold = .01
        
        if np.abs(linear[2])<linear_threshold and np.all(np.abs(angular)<angular_threshold):
            self._reached_position = True
            return True
        goal.wrench.force.z = -2*self._push_force
        
        if self._virtual or self._current_action.sim.data:
            self._sim_pose_pub.publish(goal)
        else:
            self._pose_pub.publish(goal)
        
        return False

    def go_to_position(self):
        action = self._current_action
        goal = copy.deepcopy(action.pose)
        #goal.sel_vector = [1,1,1,0,0,0]
        #goal.constraint_frame.w=1
        
        if self._camera_control:
            ee_frame = "rotated_camera"
        else:
            ee_frame = ('sim_' if action.sim.data else '') + 'end_effector'

        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, ee_frame, rospy.Time(0))
        linear,angular = self.get_diff_pose_trans(goal.pose,t)

        linear_threshold = .001
        angular_threshold = .01
        sel_vector = [goal.sel_vector[0],goal.sel_vector[1],goal.sel_vector[2],goal.sel_vector[3],goal.sel_vector[4],goal.sel_vector[5]]

        if np.all(sel_vector[:3]*np.abs(linear)<linear_threshold) and np.all(sel_vector[3:6]*np.abs(angular)<angular_threshold):
            return True
    
        progress = min((rospy.Time.now() - self._starting_time).to_sec()/(goal.header.stamp - self._starting_time).to_sec(),1)
        progress = min(progress,1)
        goal.pose = self.interpolate_poses(self._starting_pose.pose, goal.pose,progress)
        if self._virtual or self._current_action.sim.data:
            self._sim_pose_pub.publish(goal)
        else:
            self._pose_pub.publish(goal)
        if progress == 1:
            return True
    
        return False

    def camera_control(self, start):
        if self._camera_control == start:
            return
        if start:
            self._event_pub.publish(String("start_cam"))
            self._chain_pub.publish(String("pandaCamera"))
            self._link_pub.publish(String("cameraLink"))
        else:
            self._event_pub.publish(String("stop_cam"))
            self._chain_pub.publish(String("pandaFlange"))
            self._link_pub.publish(String("pandaGripper"))
        self._camera_control = start

    def view(self):
        #if wrong mode change
        self.camera_control(True)
        return self.go_to_position()

    def camera_velocity(self):
        self.camera_control(True)
        if not self._velocity_sent:
            msg = TwistStamped()
            msg.twist = self._current_action.velocity
            msg.header.stamp = rospy.Time.now()+rospy.Duration(.5)
            self._cart_vel_pub.publish(msg)
        if (rospy.Time.now() - self._starting_time).to_sec() > .5:
            msg = TwistStamped()
            msg.twist.linear.x=random.random()/10000.
            msg.twist.linear.y=random.random()/10000.
            msg.twist.linear.z=random.random()/10000.
            msg.twist.angular.x=random.random()/10000.
            msg.twist.angular.y=random.random()/10000.
            msg.twist.angular.z=random.random()/10000.
            msg.header.stamp = rospy.Time.now()+rospy.Duration(.5)
            self._cart_vel_pub.publish(msg)
            return True

    def success(self,val = True):
        #TODO Make the robot stop
        if val and self._on_success is not None:
            self._on_success()
        self._on_success = None
        self._result.success = Bool(val)
        self._as.set_succeeded(self._result)
        self._current_action = None
        self._search_theta = 0
        self._insert_progress = 0

###### Helper functions ######

    def get_time_between_pose(self, start, end):
        linear,angular = self.get_diff_poses(start,end)
        max_v_lin = .12
        max_v_ang = .6
        t_lin = np.sqrt(np.sum(linear**2)) / max_v_lin
        t_ang = max(np.fabs(angular))/max_v_ang
        return max(t_lin,t_ang)
        
    def get_diff_poses(self,p1, p2):
        linear = np.array([p1.position.x-p2.position.x, p1.position.y-p2.position.y, p1.position.z-p2.position.z])
        qp1 = PyKDL.Rotation.Quaternion(p1.orientation.x,p1.orientation.y,p1.orientation.z,p1.orientation.w)
        qp2 = PyKDL.Rotation.Quaternion(p2.orientation.x,p2.orientation.y,p2.orientation.z,p2.orientation.w)
        qd = qp1*qp2.Inverse()
        a1 = qp1.GetRPY()
        ad = qd.GetRPY()
        angular = np.array(ad)
        d = a1[2] + ad[2]
        if d > np.pi:
            angular[2] -= 2 * np.pi
        if d < -np.pi:
            angular[2] += 2 * np.pi 
        return (linear,angular)
    
    
    def get_diff_pose_trans(self,pose, t):
        trans = t.transform.translation
        rot = t.transform.rotation
        linear = np.array([pose.position.x-trans.x, pose.position.y-trans.y, pose.position.z-trans.z])
        qp = PyKDL.Rotation.Quaternion(rot.x,rot.y,rot.z,rot.w)
        current_angle = qp.GetRPY()
        rot = pose.orientation
        qg = PyKDL.Rotation.Quaternion(rot.x,rot.y,rot.z,rot.w)
        q = qg*qp.Inverse()
        difference_angle = q.GetRPY()
        angular = np.array(difference_angle)
        d = current_angle[2] + difference_angle[2]
        if d > np.pi:
            angular[2] -= 2 * np.pi
        if d < -np.pi:
            angular[2] += 2 * np.pi 
        return (linear,angular)
    
    def get_pose_from_trans(self,t):
        p=PoseStamped()
        p.header=t.header
        p.pose.position.x = t.transform.translation.x
        p.pose.position.y = t.transform.translation.y
        p.pose.position.z = t.transform.translation.z
        p.pose.orientation.x = t.transform.rotation.x
        p.pose.orientation.y = t.transform.rotation.y
        p.pose.orientation.z = t.transform.rotation.z
        p.pose.orientation.w = t.transform.rotation.w
        return p

    def interpolate_poses(self, p1, p2, ratio):
        pose = Pose()
        pose.position.x = p1.position.x+(p2.position.x-p1.position.x)*ratio
        pose.position.y = p1.position.y+(p2.position.y-p1.position.y)*ratio
        pose.position.z = p1.position.z+(p2.position.z-p1.position.z)*ratio
        q1 = [p1.orientation.x,p1.orientation.y,p1.orientation.z,p1.orientation.w]
        q2 = [p2.orientation.x,p2.orientation.y,p2.orientation.z,p2.orientation.w]
        key_rots = R.from_quat([q1,q2])
        key_times = [0, 1]
        slerp = Slerp(key_times, key_rots)
        interp_rots = slerp([ratio]).as_quat()[0]
        pose.orientation.x = interp_rots[0]
        pose.orientation.y = interp_rots[1]
        pose.orientation.z = interp_rots[2]
        pose.orientation.w = interp_rots[3]
        return pose

if __name__ == '__main__':
    rospy.init_node('mover_server')
    mover = AuthoringAction('mover_server')
    rospy.spin()