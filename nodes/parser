#!/usr/bin/env python
import numpy as np
import math
import rospy
import signal
#https://github.com/eric-wieser/ros_numpy
import ros_numpy
import sys
import cv2
from threading import Event
from std_msgs.msg import String
from sensor_msgs.msg import Image, PointCloud2, CameraInfo
import image_geometry
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker
from geometry_msgs.msg import PoseStamped, Point, Pose, PoseArray
from authoring_msgs.msg import Action, Command
import tf
import copy

REFERENCE_FRAME='panda_link0'

class Parser(object):
    def __init__(self):
        self._tl = tf.TransformListener()
        rospy.sleep(0.5) # sleep a bit to make sure the TF cache is filled
        self._pose_pub = rospy.Publisher("/grasping_point",PoseStamped,queue_size=1)
        self._command_pub = rospy.Publisher("/planner/command", Command,queue_size=1)
        self._marker_pub = rospy.Publisher("/gui/markers",Marker,queue_size=1)
        self._model = image_geometry.PinholeCameraModel()
        self._model.fromCameraInfo(rospy.wait_for_message("rgb/camera_info", CameraInfo))
        self._feedback_pub = rospy.Publisher("/gui/feedback",String,queue_size=1)

        self._br = tf.TransformBroadcaster()
        self._poi = []
        self._poi_sub = rospy.Subscriber("/poi", PoseArray, self.on_poi, queue_size = 1)
        self._command_sub = rospy.Subscriber("gui/command", String, self.on_command, queue_size = 1)

    def on_poi(self, msg):
        for p in msg.poses:
            pose = PoseStamped()
            pose.header = msg.header
            pose.pose = p
            pose = self._tl.transformPose(REFERENCE_FRAME, pose)
            self._poi.append(pose)
        print "got "+str(len(self._poi))+" pois"

    def get_xyz_from_pixel(self,x,y,d):
        p = [x,y]
        p = self._model.rectifyPoint(p)
        p3d = self._model.projectPixelTo3dRay(p)
        point = Point()
        point.x=d/p3d[2]*p3d[0]
        point.y=d/p3d[2]*p3d[1]
        point.z=d/p3d[2]*p3d[2]
        return point
        
    def publish_pose(self,point):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id="rgb_camera_link"
        pose = self._tl.transformPose(REFERENCE_FRAME, pose)
        q = tf.transformations.quaternion_from_euler(math.pi,0,0)
        pose.pose.orientation.x=q[0]
        pose.pose.orientation.y=q[1]
        pose.pose.orientation.z=q[2]
        pose.pose.orientation.w=q[3]
        pose.header.stamp=rospy.Time.now()
        self._pose_pub.publish(pose)

    def publish_spiral(self,point,name,i,scale,color,alpha=1):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        #Get everything in the panda pose
 
        marker.pose.position = point
        marker.ns = name
        marker.id = i
        marker.scale.x=scale/20.
        #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
        color=color.lstrip('#')
        (r,g,b) = tuple(int(color[i:i+2], 16)/255. for i in (0, 2, 4))
        marker.color.r = r
        marker.color.g = g
        marker.color.b = b
        marker.color.a=alpha
        marker.type = marker.LINE_STRIP
        for i in range(100):
            angle = i*np.pi/25.
            r = scale/2*i/100
            p = Point()
            p.x+=r*np.cos(angle)
            p.y+=r*np.sin(angle)
            marker.points.append(p)

        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def publish_sphere(self,point,name,i,scale,color,alpha=1):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.ns = name
        marker.id = i
        marker.scale.x=scale
        marker.scale.y=scale
        marker.scale.z=scale
        #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
        color=color.lstrip('#')
        (r,g,b) = tuple(int(color[i:i+2], 16)/255. for i in (0, 2, 4))
        marker.color.r = r
        marker.color.g = g
        marker.color.b = b
        marker.color.a=alpha
        marker.type = marker.SPHERE
        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def publish_arrow(self,name, index, points,scale,color,alpha=.5):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.ns = name
        marker.id = index
        marker.scale.x=scale/2
        marker.scale.y=scale
        marker.scale.z=scale
        #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
        color=color.lstrip('#')
        (r,g,b) = tuple(int(color[i:i+2], 16)/255. for i in (0, 2, 4))
        marker.color.r = r
        marker.color.g = g
        marker.color.b = b
        marker.points = points
        marker.color.a=alpha
        marker.type = marker.ARROW
        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def on_command(self, message):
        list_actions = message.data.split(";")
        command_type = list_actions[0]
        if command_type == 'remove':
            cmd = list_actions[1].split(":")

            marker = Marker()
            if cmd[0] == "all":
                marker.action = marker.DELETEALL
                self._marker_pub.publish(marker)
                return
            marker.action = marker.DELETE
            marker.ns = cmd[0]
            marker.id = int(cmd[1])
            self._marker_pub.publish(marker)
            return
        actions = []

        list_actions.pop(0)
        image = ros_numpy.numpify(rospy.wait_for_message("depth_to_rgb/image_raw", Image))

        for action in list_actions:
            cmd = action.split(":")
        
            name = cmd[0]
            index = int(cmd[1])
            x = int(cmd[2])
            y = int(cmd[3])
            width = int(cmd[4])
            color = cmd[7]
            if name == 'arrow':
                angle = int(cmd[6])*2*np.pi/360.+np.pi
                x_tail = x+int(width/2*np.cos(angle))
                y_tail = y+int(width/2*np.sin(angle))
                x-=int(width/2*np.cos(angle))
                y-=int(width/2*np.sin(angle))
            d = image[y,x]
            print "depth: "+str(d)
            if d == 0.0:
                print name
                print index
                print "bad depth"
                self._feedback_pub.publish(String("bad_depth"))
                return None
            self._feedback_pub.publish(String("good_depth"))

            #Still in camera frame
            point = self.get_xyz_from_pixel(x,y,d)
            scale = width*point.z/1000
            #And transform to reference frame
            point = self.snap_to_poi(point,scale)

            action = Action()
            if name == 'spiral':
                self.publish_spiral(point,name,index,scale=scale,color=color,alpha=.5)
                action.type = action.SCREW
            if name == 'circle':
                self.publish_sphere(point,name,index,scale=scale,color=color,alpha=.5)
                action.type = action.PICK
            if name == 'arrow':
                point2 = self.get_xyz_from_pixel(x_tail,y_tail,d)
                point2 = self.snap_to_poi(point2, scale)
                points=[point2,point]
                self.publish_arrow(name, index, points,scale=.05,color=color,alpha=.5)
                action.type = action.PLACE 

            action.id = index
            action.pose.header.frame_id = REFERENCE_FRAME
            action.pose.pose.position = point
            action.pose.pose.orientation.w = 1
            actions.append(action)

        if command_type == "exec":
            cmd = Command()
            for action in actions:
                cmd.core_action.append(action)
            self._command_pub.publish(cmd)

    def snap_to_poi(self,point,scale):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id = "rgb_camera_link"
        pose = self._tl.transformPose(REFERENCE_FRAME, pose)
        point = pose.pose.position
        d_min=scale
        to_return = point
        for p in self._poi:
            d = self.distance(p.pose.position,point)
            if d < scale/2:
                d_min = scale
                to_return = p.pose.position
                print "snapping"
        return to_return

    def distance(self, p1, p2):
        return np.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2+(p1.z-p2.z)**2)


    def run(self):
        rospy.spin()

    def signal_handler(self, signal, frame):
        sys.exit()

if __name__ == "__main__":
    rospy.init_node('parser')
    parser = Parser()
    signal.signal(signal.SIGINT, parser.signal_handler)
    parser.run()
