#!/usr/bin/env python
import numpy as np
import math
import rospy
import signal
#https://github.com/eric-wieser/ros_numpy
import ros_numpy
import sys
import cv2
from threading import Event
from std_msgs.msg import String
from sensor_msgs.msg import Image, PointCloud2, CameraInfo
import image_geometry
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker
from geometry_msgs.msg import PoseStamped, Point, Pose, PoseArray, Quaternion, Twist
from std_msgs.msg import ColorRGBA
from authoring_msgs.msg import Action, Command, POI, POIArray
import tf
import copy
from tf.transformations import quaternion_from_euler

REFERENCE_FRAME='panda_link0'
CAMERA_FRAME='external_rgb_camera_link'

class Parser(object):
    def __init__(self):
        self._tl = tf.TransformListener()
        rospy.sleep(0.5) # sleep a bit to make sure the TF cache is filled
        self._pose_pub = rospy.Publisher("/grasping_point",PoseStamped,queue_size=1)
        self._command_pub = rospy.Publisher("/parser/command", Command, queue_size=1)
        self._marker_pub = rospy.Publisher("/gui/markers", Marker, queue_size=1)
        self._model = image_geometry.PinholeCameraModel()
        self._model.fromCameraInfo(rospy.wait_for_message("rgb/camera_info", CameraInfo))
        self._feedback_pub = rospy.Publisher("/gui/feedback",String,queue_size=1)
        self._vel_pub = rospy.Publisher("/panda/cart_vel",Twist,queue_size=1)

        self._br = tf.TransformBroadcaster()
        rospy.sleep(.5)
        self._pois = []
        self._poi_sub = rospy.Subscriber("/pois", POIArray, self.on_poi, queue_size = 1)
        self._command_sub = rospy.Subscriber("gui/command", String, self.on_command, queue_size = 1)

    def on_poi(self, msg):
        poi_gui="poi;"
        for p in msg.poi_array:
            p.pose = self._tl.transformPose(REFERENCE_FRAME, p.pose)
            self._pois.append(p)
            if p.type == p.SCREW:
                self.publish_mesh(p.pose.pose, "screw", p.id, "#a9a9a9",.70)

            #Inform interface of poi
            pixel = self.get_pixel_from_pose(p.pose)
            name = self.get_name(p)
            poi_gui+=name+":"+pixel+";"

        poi_gui = poi_gui[:-1]
        self._gui_pub.publish(poi_gui)

    def get_name(self, poi):
        name = ""
        if poi.type == poi.SCREW:
            name = "screw:"
        if poi.type == poi.HOLE:
            name = "hole:"
        if poi.type == poi.PUSHER:
            name = "pusher:"
        if poi.type == poi.SCREW_DRIVER:
            name = "screwdriver:"
        name += str(poi.id)
        return name

    def get_xyz_from_pixel(self,x,y,d):
        p = [x,y]
        p = self._model.rectifyPoint(p)
        p3d = self._model.projectPixelTo3dRay(p)
        point = Point()
        point.x=d/p3d[2]*p3d[0]
        point.y=d/p3d[2]*p3d[1]
        point.z=d/p3d[2]*p3d[2]
        return point
    
    def get_pixel_from_pose(self, pose):
        p = self._tl.transformPose(CAMERA_FRAME,pose)
        p = p.pose.position
        p=[p.x,p.y,p.z]
        pixel = self._model.project3dToPixel(p)
        return str(int(pixel[0]))+","+str(int(pixel[1]))

    def get_pixel_from_point(self, p):
        pose = PoseStamped()
        pose.pose.position = p
        pose.pose.orientation.w = 1
        pose.header.frame_id = REFERENCE_FRAME
        return self.get_pixel_from_pose(pose)

    def publish_pose(self,point):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id=CAMERA_FRAME
        pose = self._tl.transformPose(REFERENCE_FRAME, pose)
        q = tf.transformations.quaternion_from_euler(math.pi,0,0)
        pose.pose.orientation.x=q[0]
        pose.pose.orientation.y=q[1]
        pose.pose.orientation.z=q[2]
        pose.pose.orientation.w=q[3]
        pose.header.stamp=rospy.Time.now()
        self._pose_pub.publish(pose)

    def publish_mesh(self, pose, name, i, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose = copy.deepcopy(pose)
        marker.pose.position.z-=.043
        marker.ns = name
        marker.id = i
        scale = 1
        marker.scale.x=scale
        marker.scale.y=scale
        marker.scale.z=scale
        marker.color = self.get_color(color, alpha)
        marker.type = marker.MESH_RESOURCE
        marker.mesh_resource = "package://authoring/meshes/"+name+".stl"
        self._marker_pub.publish(marker)


    def get_orientation_from_quaternion(self, q):
        rot = Quaternion()
        rot.x=q[0]
        rot.y=q[1]
        rot.z=q[2]
        rot.w=q[3]
        return rot

    #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
    def get_color(self, string, alpha):
        color = ColorRGBA()
        string=string.lstrip('#')
        (r,g,b) = tuple(int(string[i:i+2], 16)/255. for i in (0, 2, 4))
        color.r = r
        color.g = g
        color.b = b
        color.a=alpha
        return color

    def publish_spiral(self,name,i,point,scale,color,alpha=1):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.ns = name
        marker.id = i
        marker.scale.x=scale/20.
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_STRIP
        for i in range(100):
            angle = i*np.pi/25.
            r = scale/2*i/100
            p = Point()
            p.x+=r*np.cos(angle)
            p.y+=r*np.sin(angle)
            marker.points.append(p)

        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def publish_cross(self, point, name, i, width, height, rotation, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.pose.orientation = self.get_orientation_from_quaternion([0,0,0,1])
        marker.ns = name
        marker.id = i
        marker.scale.x = .02
        marker.scale.y = .02
        marker.scale.z = .02
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_LIST
        marker.points = self.get_points_cross(width,height)
        self._marker_pub.publish(marker)

    def publish_rectangle(self, name, i, points, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = Point()
        marker.pose.orientation = self.get_orientation_from_quaternion([0,0,0,1])
        marker.ns = name
        marker.id = i
        marker.scale.x = .05
        marker.scale.y = .05
        marker.scale.z = .05
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_STRIP
        marker.points = points+[points[0]]
        self._marker_pub.publish(marker)

    def publish_surface(self, name, i, points, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = Point()
        marker.pose.orientation = self.get_orientation_from_quaternion([0,0,0,1])
        marker.ns = name
        marker.id = i
        marker.scale.x = .05
        marker.scale.y = .05
        marker.scale.z = .05
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_STRIP
        marker.points = points+[points[0]]
        self._marker_pub.publish(marker)

    def publish_sphere(self,name,i,point,scale,color,alpha=1):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.ns = name
        marker.id = i
        marker.scale.x=scale
        marker.scale.y=scale
        marker.scale.z=scale
        marker.color = self.get_color(color, alpha)
        marker.type = marker.SPHERE
        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def publish_arrow(self,name, index, points,scale,color,alpha=.5):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.ns = name
        marker.id = index
        marker.scale.x=scale/2
        marker.scale.y=scale
        marker.scale.z=scale
        marker.color = self.get_color(color, alpha)
        marker.points = [points[1],points[0]]
        marker.color.a=alpha
        marker.type = marker.ARROW
        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def get_points(self, cmd):
        l = cmd.split("_")
        points = []
        for p in l:
            point = Point()
            coord = p.split(',')
            point.x = int(coord[0])
            point.y = int(coord[1])
            points.append(point)
        return points

    def on_command(self, message):
        list_actions = message.data.split(";")
        command_type = list_actions[0]
        if command_type == 'mouse':
            arg = list_actions[1].split(":")
            twist = Twist()
            twist.linear.x = int(arg[0])/3000.
            twist.linear.y = int(arg[1])/3000.
            twist.linear.z = int(arg[2])/3000.
            twist.angular.z = int(arg[3])/3000.
            self._vel_pub.publish(twist)
            return
        if command_type == 'remove':
            cmd = list_actions[1].split(":")

            marker = Marker()
            if cmd[0] == "all":
                marker.action = marker.DELETEALL
                self._marker_pub.publish(marker)
                return
            marker.action = marker.DELETE
            marker.ns = cmd[0]
            marker.id = int(cmd[1])
            self._marker_pub.publish(marker)
            return
        actions = []

        list_actions.pop(0)
        image = ros_numpy.numpify(rospy.wait_for_message("depth_to_rgb/image_raw", Image))
        snap_str = "snap;"

        for action in list_actions:
            cmd = action.split(":")
        
            name = cmd[0]
            index = int(cmd[1])
            points = self.get_points(cmd[2])
            color = cmd[3]
            scale = None
            framed_points = []

            point = Point()
            point.x = points[0].x
            point.y = points[0].y
            d = image[point.y,point.x]
            if d == 0.0:
                print name
                print index
                print "bad depth"
                self._feedback_pub.publish(String("bad_depth"))
                return None

            #Still in camera frame
            p = self.get_xyz_from_pixel(point.x,point.y,d)
            if len(points) == 2:
                scale = np.sqrt((points[0].x-points[1].x)**2 + (points[0].y-points[1].y)**2)*p.z/500.
            else:
                scale = .0001
            if name == "arrow":
                scale = scale/2.

            #And transform to reference frame
            (p,object_str) = self.snap_to_poi(p,scale)
            snap_str += name+":"+str(index)+":"+self.get_pixel_from_point(p)+";"

            framed_points.append(p)
            for p in points[1:]:
                if len(points) != 2:
                    d = image[p.y,p.x]
                    if d == 0.0:
                        print name
                        print index
                        print "bad depth"
                        self._feedback_pub.publish(String("bad_depth"))
                        return None
                p = self.get_xyz_from_pixel(p.x, p.y,d)
                (p,_) = self.snap_to_poi(p,scale)
                framed_points.append(p)
            points = framed_points

            self._feedback_pub.publish(String("good_depth"))

            action = Action()
            action.item = String(object_str)
            if name == 'surface':
                self.publish_surface(name, index, points, color, alpha=.5)
                action.type = action.COVER
                continue

            if name == 'rect':
                self.publish_rectangle(name, index, points, color, alpha=.5)
                continue

            if name == 'spiral':
                self.publish_spiral(name,index,points[0],scale=scale,color=color,alpha=1)
                action.type = action.SCREW
            if name == 'circle':
                self.publish_sphere(name,index,points[0],scale=scale,color=color,alpha=.5)
                action.type = action.PICK
            if name == 'arrow':
                self.publish_arrow(name, index, points,scale=.05,color=color,alpha=.5)
                action.type = action.PLACE 

            action.id = index
            action.pose.header.frame_id = REFERENCE_FRAME
            action.pose.pose.position = points[0]
            action.pose.pose.orientation.w = 1
            actions.append(action)
        self._feedback_pub.publish(String(snap_str))

        cmd = Command()
        if command_type == "exec":
            cmd.type = cmd.EXEC
        if command_type == "sim":
            cmd.type = cmd.SIM
        if command_type == "viz":
            cmd.type = cmd.VIZ
        for action in actions:
            cmd.core_action.append(action)
        self._command_pub.publish(cmd)

    def snap_to_poi(self,point,scale):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id = CAMERA_FRAME
        pose = self._tl.transformPose(REFERENCE_FRAME, pose)
        point = pose.pose.position
        d_min=scale/2
        to_return = (point,"")
        for p in self._pois:
            d = self.distance(p.pose.pose.position,point)
            if d < d_min:
                d_min = d
                to_return = (p.pose.pose.position,self.get_name(p))
        return to_return

    def distance(self, p1, p2):
        return np.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2+(p1.z-p2.z)**2)


    def run(self):
        rospy.spin()

    def signal_handler(self, signal, frame):
        sys.exit()

if __name__ == "__main__":
    rospy.init_node('parser')
    parser = Parser()
    signal.signal(signal.SIGINT, parser.signal_handler)
    parser.run()
