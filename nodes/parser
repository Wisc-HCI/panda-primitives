#!/usr/bin/env python
import numpy as np
import math
import rospy
import signal
#https://github.com/eric-wieser/ros_numpy
import ros_numpy
import sys
import cv2
from threading import Event
from std_msgs.msg import String
from sensor_msgs.msg import Image, PointCloud2, CameraInfo
import image_geometry
from cv_bridge import CvBridge, CvBridgeError
from visualization_msgs.msg import Marker
from geometry_msgs.msg import PoseStamped, Point, Pose, PoseArray, Quaternion, Twist
from std_msgs.msg import ColorRGBA
from authoring_msgs.msg import Action, Command, POI, POIArray
import tf
import copy
from tf.transformations import quaternion_from_euler
import tf2_ros
import tf2_geometry_msgs

REFERENCE_FRAME='panda_link0'
CAMERA_FRAME='camera1'

class Parser(object):
    def __init__(self):
        self._tfBuffer = tf2_ros.Buffer()
        self._tl = tf2_ros.TransformListener(self._tfBuffer)
        rospy.sleep(0.5) # sleep a bit to make sure the TF cache is filled
        self._pose_pub = rospy.Publisher("/grasping_point",PoseStamped,queue_size=1)
        self._command_pub = rospy.Publisher("/parser/command", Command, queue_size=1)
        self._marker_pub = rospy.Publisher("/gui/markers", Marker, queue_size=1)

        self._virtual = rospy.get_param('~only_virtual')
        self._camera_topic = "/rgb/" if not self._virtual else "/virtual_camera/"

        print self._camera_topic+"camera_info"

        self._model = image_geometry.PinholeCameraModel()
        self._model.fromCameraInfo(rospy.wait_for_message(self._camera_topic+"camera_info", CameraInfo))

        self._gui_pub = rospy.Publisher("/parser/gui_info",String,queue_size=1)
        self._vel_pub = rospy.Publisher("/panda/cart_vel",Twist,queue_size=1)
        self._panda_command = rospy.Publisher("/panda/commands",String, queue_size=1)

        self._br = tf.TransformBroadcaster()
        rospy.sleep(.5)
        self._pois = []
        self._poi_gui = ""
        self._poi_sub = rospy.Subscriber("/world_state/pois", POIArray, self.on_poi, queue_size = 1)
        self._command_sub = rospy.Subscriber("/gui/command", String, self.on_command, queue_size = 1)
        self._event_sub = rospy.Subscriber("/event", String, self.on_event, queue_size = 1)
        
        self._camera_t = None
        self._freq = 1

    def on_event(self, msg):
        l = msg.data.split(";")
        event = l[0]
        
        if event == "motion_finished" or event == "wait":
            self.publish_pois()

    def on_poi(self, msg):
        self._pois = []
        for p in msg.poi_array:
            self._pois.append(p)
        self.publish_pois()

    def publish_pois(self):
        self._poi_gui="poi;"
        done = False
        while not done:
            try:
                for p in self._pois:
                    #Inform interface of poi
                    pixel = self.get_pixel_from_pose(p.pose)
                    name = self.get_name(p)
                    self._poi_gui+=name+":"+pixel+";"

                self._poi_gui = self._poi_gui[:-1]
                self._gui_pub.publish(self._poi_gui)
                done = True
            except:
                pass

    def get_vect(self, v):
        toreturn = []
        try:
            toreturn.append(v.x)
            toreturn.append(v.y)
            toreturn.append(v.z)
            toreturn.append(v.w)
        except:
            pass
        return toreturn

    def get_name(self, poi):
        name = ""
        if poi.type == poi.SCREW:
            name = "screw:"
        if poi.type == poi.HOLE:
            name = "hole:"
        if poi.type == poi.PUSHER:
            name = "pusher:"
        if poi.type == poi.SCREW_DRIVER:
            name = "screwdriver:"
        name += str(poi.id)
        return name

    def get_xyz_from_pixel(self,x,y,d):
        p = [x,y]
        p = self._model.rectifyPoint(p)
        p3d = self._model.projectPixelTo3dRay(p)
        point = Point()
        point.x=d/p3d[2]*p3d[0]
        point.y=d/p3d[2]*p3d[1]
        point.z=d/p3d[2]*p3d[2]
        return point
    
    def get_pixel_from_pose(self, pose):
        p = self._tfBuffer.transform(pose,CAMERA_FRAME)
        p = p.pose.position
        p=[p.x,p.y,p.z]
        pixel = self._model.project3dToPixel(p)
        return str(int(pixel[0]))+","+str(int(pixel[1]))

    def get_pixel_from_point(self, p):
        pose = PoseStamped()
        pose.pose.position = p
        pose.pose.orientation.w = 1
        pose.header.frame_id = REFERENCE_FRAME
        return self.get_pixel_from_pose(pose)

    def publish_pose(self,point):
        pose = PoseStamped()
        pose.pose.position=point
        pose.pose.orientation.w=1
        pose.header.frame_id=CAMERA_FRAME
        pose = self._tfBuffer.transform(pose,REFERENCE_FRAME)
        q = tf.transformations.quaternion_from_euler(math.pi,0,0)
        pose.pose.orientation.x=q[0]
        pose.pose.orientation.y=q[1]
        pose.pose.orientation.z=q[2]
        pose.pose.orientation.w=q[3]
        pose.header.stamp=rospy.Time.now()
        self._pose_pub.publish(pose)

    def publish_mesh(self, pose, name, i, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose = copy.deepcopy(pose)
        marker.pose.position.z-=.043
        marker.ns = name
        marker.id = i
        scale = 1
        marker.scale.x=scale
        marker.scale.y=scale
        marker.scale.z=scale
        marker.color = self.get_color(color, alpha)
        marker.type = marker.MESH_RESOURCE
        marker.mesh_resource = "package://authoring/meshes/"+name+".stl"
        self._marker_pub.publish(marker)


    def get_orientation_from_quaternion(self, q):
        rot = Quaternion()
        rot.x=q[0]
        rot.y=q[1]
        rot.z=q[2]
        rot.w=q[3]
        return rot

    #from https://stackoverflow.com/questions/29643352/converting-hex-to-rgb-value-in-python
    def get_color(self, string, alpha):
        color = ColorRGBA()
        string=string.lstrip('#')
        (r,g,b) = tuple(int(string[i:i+2], 16)/255. for i in (0, 2, 4))
        color.r = r
        color.g = g
        color.b = b
        color.a=alpha
        return color

    def publish_spiral(self,name,i,point,scale,color,alpha=1):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.ns = name
        marker.id = i
        marker.scale.x=scale/20.
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_STRIP
        for i in range(100):
            angle = i*np.pi/25.
            r = scale/2*i/100
            p = Point()
            p.x+=r*np.cos(angle)
            p.y+=r*np.sin(angle)
            marker.points.append(p)

        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def publish_cross(self, point, name, i, width, height, rotation, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.pose.orientation = self.get_orientation_from_quaternion([0,0,0,1])
        marker.ns = name
        marker.id = i
        marker.scale.x = .02
        marker.scale.y = .02
        marker.scale.z = .02
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_LIST
        marker.points = self.get_points_cross(width,height)
        self._marker_pub.publish(marker)

    def publish_rectangle(self, name, i, points, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = Point()
        marker.pose.orientation = self.get_orientation_from_quaternion([0,0,0,1])
        marker.ns = name
        marker.id = i
        marker.scale.x = .05
        marker.scale.y = .05
        marker.scale.z = .05
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_STRIP
        marker.points = points+[points[0]]
        self._marker_pub.publish(marker)

    def publish_surface(self, name, i, points, color, alpha):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = Point()
        marker.pose.orientation = self.get_orientation_from_quaternion([0,0,0,1])
        marker.ns = name
        marker.id = i
        marker.scale.x = .05
        marker.scale.y = .05
        marker.scale.z = .05
        marker.color = self.get_color(color, alpha)
        marker.type = marker.LINE_STRIP
        marker.points = points+[points[0]]
        self._marker_pub.publish(marker)

    def publish_sphere(self,name,i,point,scale,color,alpha=1):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.pose.position = point
        marker.ns = name
        marker.id = i
        marker.scale.x=scale
        marker.scale.y=scale
        marker.scale.z=scale
        marker.color = self.get_color(color, alpha)
        marker.type = marker.SPHERE
        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def publish_arrow(self,name, index, points,scale,color,alpha=.5):
        marker = Marker()
        marker.header.frame_id = REFERENCE_FRAME
        marker.ns = name
        marker.id = index
        marker.scale.x=scale/2
        marker.scale.y=scale
        marker.scale.z=scale
        marker.color = self.get_color(color, alpha)
        marker.points = [points[1],points[0]]
        marker.color.a=alpha
        marker.type = marker.ARROW
        marker.pose.orientation.w=1
        self._marker_pub.publish(marker)

    def get_points(self, cmd):
        l = cmd.split("_")
        points = []
        for p in l:
            point = Point()
            coord = p.split(',')
            point.x = int(coord[0])
            point.y = int(coord[1])
            points.append(point)
        return points

    def get_pose_from_trans(self, t):
        pose = Pose()
        pose.position.x = t.transform.translation.x
        pose.position.y = t.transform.translation.y
        pose.position.z = t.transform.translation.z
        pose.orientation.x = t.transform.rotation.x
        pose.orientation.y = t.transform.rotation.y
        pose.orientation.z = t.transform.rotation.z
        pose.orientation.w = t.transform.rotation.w
        return pose


    def on_command(self, message):
        list_actions = message.data.split(";")
        command_type = list_actions[0]
        if command_type == 'init_gui' or command_type == "lock":
            self.publish_pois()
        if command_type == 'mouse':
            arg = list_actions[1].split(":")
            scale = .001
            target = PoseStamped()
            target.header.frame_id = "internal_rgb_camera_link"
            target.pose.position.x = float(arg[0])*scale
            target.pose.position.y = float(arg[1])*scale
            target.pose.orientation.w = 1
            target = self._tfBuffer.transform(target,REFERENCE_FRAME)
            print target
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "end_effector", rospy.Time(0)) 
            t_camera = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "internal_rgb_camera_link", rospy.Time(0)) 
            t.transform.translation.x += target.pose.position.x - t_camera.transform.translation.x
            t.transform.translation.y += target.pose.position.y - t_camera.transform.translation.y
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = action.MOVE
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'zoom_in':
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "end_effector", rospy.Time(0)) 
            t.transform.translation.z -= .05
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = action.MOVE
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'zoom_out':
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "end_effector", rospy.Time(0)) 
            t.transform.translation.z += .05
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = action.MOVE
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "go":
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "go_camera", rospy.Time(0)) 
            action.type = action.MOVE
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "reset_position":
            print "here"
            self._panda_command.publish(String("release"))
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            action.type = action.RESET
            pose = Pose()
            pose.position.x = 0.25
            pose.position.y = 0.
            pose.position.z = 0.5
            pose.orientation.w = 1
            action.poses.poses.append(pose)
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "stop_sim":
            action = Action()
            action.type = action.STOP
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "end_effector", rospy.Time(0)) 
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.SIM
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == "stop":
            action = Action()
            action.type = action.STOP
            action.poses.header.frame_id = REFERENCE_FRAME
            t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, "end_effector", rospy.Time(0)) 
            pose = self.get_pose_from_trans(t)
            action.poses.poses.append(pose) 
            cmd = Command()
            cmd.type = cmd.EXEC
            cmd.core_action.append(action)
            self._command_pub.publish(cmd)
            return

        if command_type == 'remove':
            cmd = list_actions[1].split(":")

            marker = Marker()
            if cmd[0] == "all":
                marker.action = marker.DELETEALL
                self._marker_pub.publish(marker)
                return
            marker.action = marker.DELETE
            marker.ns = cmd[0]
            marker.id = int(cmd[1])
            self._marker_pub.publish(marker)
            return
        actions = []

        list_actions.pop(0)
        if not self._virtual:
            image = ros_numpy.numpify(rospy.wait_for_message("depth_to_rgb/image_raw", Image))

        moved = {}
        for action in list_actions:
            cmd = action.split(":")
        
            name = cmd[0]
            item = ""
            action = Action()
            action.poses.header.frame_id = REFERENCE_FRAME
            #Get item name
            if cmd[0] == "Reset":
                action.type = action.RESET
                action.poses.header.frame_id = REFERENCE_FRAME
                pose = Pose()
                pose.position.x = 0.25
                pose.position.y = 0.
                pose.position.z = 0.5
                pose.orientation.w = 1
                action.poses.poses.append(pose)
    
            #elif cmd[0] == "Move":
            #    action.item = String(cmd[1])
            #    t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, cmd[1].split('-')[0], rospy.Time(0)) 
            #    pose = self.get_pose_from_trans(t)
            #    action.poses.poses.append(pose)
            #    t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, cmd[1].split('-')[1], rospy.Time(0)) 
            #    pose = self.get_pose_from_trans(t)
            #    action.poses.poses.append(pose)
                
            elif cmd[1].find(",") == -1:
                item_list = cmd[1].split('-')
                for item in item_list:
                    if item in moved.keys():
                        action.poses.poses.append(moved[item])
                    else:
                        t = self._tfBuffer.lookup_transform(REFERENCE_FRAME, item, rospy.Time(0)) 
                        pose = self.get_pose_from_trans(t)
                        action.poses.poses.append(pose)
                if cmd[0] == "Move":
                    action.item = String(cmd[1])
                    moved[item_list[0]]=action.poses.poses[-1]
                else:
                    action.item = String(item_list[0])

            #get item pixel coord
            else:
                for coord in cmd[1].split('_'):
                    coord = coord.split(',')
                    point = Point()
                    point.x = int(coord[0])
                    point.y = int(coord[1])
                    d = image[point.y,point.x]
                    action.item = String(cmd[1].split('_')[0])
                    if d == 0.0:
                        print "bad depth"
                        self._gui_pub.publish(String("bad_depth"))
                        return None
                    p = self.get_xyz_from_pixel(point.x,point.y,d)
                    pose = PoseStamped()
                    pose.header.frame_id = CAMERA_FRAME
                    pose.pose.position = p
                    pose.pose.orientation.w = 1
                    pose = self._tfBuffer.transform(pose,REFERENCE_FRAME)
                    pose.pose.orientation.x = 0
                    pose.pose.orientation.y = 0
                    pose.pose.orientation.z = 0
                    pose.pose.orientation.w = 1
                    action.poses.header = pose.header
                    action.poses.poses.append(pose.pose)

           #points = self.get_points(cmd[2])
            #color = cmd[3]
            #scale = None
            #framed_points = []

            #Still in camera frame
            #p = self.get_xyz_from_pixel(point.x,point.y,d)
            #if len(points) == 2:
            #    scale = np.sqrt((points[0].x-points[1].x)**2 + (points[0].y-points[1].y)**2)*p.z/500.
            #else:
            #    scale = .0001
            #if name == "arrow":
            #    scale = scale/2.

            #And transform to reference frame
            #(p,object_str) = self.snap_to_poi(p,scale)

            #framed_points.append(p)
            #for p in points[1:]:
            #    if len(points) != 2:
            #        d = image[p.y,p.x]
            #        if d == 0.0:
            #            print name
            #            print index
            #            print "bad depth"
            #            self._feedback_pub.publish(String("bad_depth"))
            #            return None
            #    p = self.get_xyz_from_pixel(p.x, p.y,d)
            #    (p,_) = self.snap_to_poi(p,scale)
            #    framed_points.append(p)
            #points = framed_points

            self._gui_pub.publish(String("good_depth"))

            #action.item = String(object_str)
            if name == 'Wipe':
                #self.publish_surface(name, index, points, color, alpha=.5)
                action.type = action.WIPE

            if name == 'rect':
                #self.publish_rectangle(name, index, points, color, alpha=.5)
                continue

            if name == 'Tighten':
                #self.publish_spiral(name,index,points[0],scale=scale,color=color,alpha=1)
                action.type = action.SCREW
            if name == 'Loosen':
                action.type = action.UNSCREW
            if name == 'Pick':
                #self.publish_sphere(name,index,points[0],scale=scale,color=color,alpha=.5)
                action.type = action.PICK
            if name == 'Place':
                #self.publish_arrow(name, index, points,scale=.05,color=color,alpha=.5)
                action.type = action.PLACE 
            if name == 'Move':
                action.type = action.MOVE_OBJECT
            if name == 'Inspect':
                action.type = action.INSPECT
            if name == 'Push':
                action.type = action.PUSH

            #action.id = index
            actions.append(action)

        cmd = Command()
        if command_type == "exec":
            cmd.type = cmd.EXEC
        if command_type == "sim":
            cmd.type = cmd.SIM
        if command_type == "viz":
            cmd.type = cmd.VIZ
        for action in actions:
            cmd.core_action.append(action)
        self._command_pub.publish(cmd)

    def distance(self, p1, p2):
        return np.sqrt((p1.x-p2.x)**2+(p1.y-p2.y)**2+(p1.z-p2.z)**2)


    def run(self):
        r = rospy.Rate(self._freq)
        while not rospy.is_shutdown():
            self.publish_pois()
            r.sleep()

    def signal_handler(self, signal, frame):
        sys.exit()

if __name__ == "__main__":
    rospy.init_node('parser')
    parser = Parser()
    signal.signal(signal.SIGINT, parser.signal_handler)
    parser.run()
